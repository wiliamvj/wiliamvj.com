<!DOCTYPE html>
<html lang="pt" class="scroll-smooth dark">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>      

<meta charset="UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Tenha controle sobre seu SQL com Golang e SQLC</title>


<meta name="description" content="" />
<meta name="author" content="map[homepage:https://wiliamvj.com name:Wiliam V. Joaquim]" />
<meta
  name="keywords"
  content="Golang, Go, GCP, Sql, Gorm, NestJS, Javascript, Typescript, AWS, SQS, RabbitMq, Kafka, microservices, brazilian devs, software developer, back-end, NodeJS, Unit tests, integration testes"
/>

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:site" content="//localhost:1313/posts/golang-sqlc/" />
<meta name="twitter:title" content="Tenha controle sobre seu SQL com Golang e SQLC" />
<meta name="twitter:description" content="" />
<meta name="twitter:image" content="//localhost:1313/posts/golang-sqlc/dfgU78Lpfdg34.png" />
<meta name="twitter:domain" content="wiliamvj.com" />
<meta name="twitter:creator" content="@wiliamjoaquim" />
<meta name="twitter:image:alt" content="Tenha controle sobre seu SQL com Golang e SQLC" />

<meta property="og:type" content="article" />
<meta property="og:title" content="Tenha controle sobre seu SQL com Golang e SQLC" />
<meta property="og:site_name" content="Wiliam V. Joaquim - Software Developer'" />
<meta property="og:description" content="" />
<meta property="og:url" content="//localhost:1313/posts/golang-sqlc/" />
<meta property="og:image" content="//localhost:1313/posts/golang-sqlc/dfgU78Lpfdg34.png" />
<meta property="og:image:alt" content="Tenha controle sobre seu SQL com Golang e SQLC" />


<meta
  name="apple-mobile-web-app-title"
  content="Tenha controle sobre seu SQL com Golang e SQLC"
/>
<meta
  name="description"
  content="Introdução Lidar com o SQL muitas vezes se torna complicado e cansativo, lidar com tantas queries, indexações, performance, segurança, transações e tudo que envolve o uso do SQL, pensando nisso cada vez mais é adotado o uso de ORM, visando facilitar nossas vidas."
/>
<link
  rel="apple-touch-icon"
  sizes="180x180"
  href="/icons/apple-touch.png"
/>
<link
  rel="icon"
  type="image/png"
  sizes="32x32"
  href="/icons/favicon-32x32.png"
/>
<link
  rel="icon"
  type="image/png"
  sizes="16x16"
  href="/icons/favicon-16x16.png"
/>
<link rel="canonical" href="//localhost:1313/posts/golang-sqlc/" />
<link rel="robots" href="/robots.txt" />
<link rel="icon" type="image/x-icon" href="/icons/favicon.ico" />


<script
  defer
  src="https://www.googletagmanager.com/gtag/js?id=G-TG8KZ9PQBT"
></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() {
    dataLayer.push(arguments);
  }
  gtag('js', new Date());

  gtag('config', 'G-TG8KZ9PQBT');
</script>


<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });</script>

<link rel="stylesheet" href="//localhost:1313/css/app.css" /></head>

  <body class="max-w-screen-md mx-auto">
    <div class="header">
      <header
  class="flex flex-col sm:flex-row items-center gap-5 sm:gap-10 pt-16 sm:py-12"
>
   


<div class="flex-none w-20 h-20 rounded-full overflow-hidden">
  <a href="//localhost:1313/">
    <img
      srcset="/img/profile-picture_hucbf2afd9e62dc6021c155b0731b41164_625734_80x80_fill_q90_box_smart1.jpg 80w"
      src="/img/profile-picture.jpg"
      width="1080"
      height="1080"
      alt="Wiliam V. Joaquim"
    />
  </a>
</div>


  <div class="flex flex-col gap-5">
    <a href="//localhost:1313/">
  <h1 id="site-title">Wiliam V<span class="text-wpurple">.</span> Joaquim</h1>
</a>
 <nav>
  <ul class="px-4 lg:px-0">
     
    <li>
      <a
        href="/"
        class=""
        
      >
        Artigos
      </a>
      <span class="text-wpurple text-lg">.</span>
    </li>
    
    <li>
      <a
        href="https://wiliamvj.substack.com/"
        class=""
         target="_blank" 
      >
        Newsletter
      </a>
      <span class="text-wpurple text-lg">.</span>
    </li>
    
    <li>
      <a
        href="/en/"
        class=""
        
      >
        en-US
      </a>
      <span class="text-wpurple text-lg">.</span>
    </li>
    
    <li class="-mt-2 block lg:hidden"><button
  class="toggle-theme"
  aria-label="Toggle Theme"
  title="Toggle Theme"
  onclick="toggleTheme()"
>
  <span class="theme-icon light hidden dark:block">
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
    <path stroke-linecap="round" stroke-linejoin="round" d="M12 3v2.25m6.364.386l-1.591 1.591M21 12h-2.25m-.386 6.364l-1.591-1.591M12 18.75V21m-4.773-4.227l-1.591 1.591M5.25 12H3m4.227-4.773L5.636 5.636M15.75 12a3.75 3.75 0 11-7.5 0 3.75 3.75 0 017.5 0z" />
</svg>
  </span>
  <span class="theme-icon dark block dark:hidden">
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
    <path stroke-linecap="round" stroke-linejoin="round" d="M21.752 15.002A9.718 9.718 0 0118 15.75c-5.385 0-9.75-4.365-9.75-9.75 0-1.33.266-2.597.748-3.752A9.753 9.753 0 003 11.25C3 16.635 7.365 21 12.75 21a9.753 9.753 0 009.002-5.998z" />
</svg>
  </span>
</button>

<script>
  document.addEventListener('DOMContentLoaded', function () {
    const theme = localStorage.getItem('theme');
    setTheme(theme);
  });

  function setTheme(theme) {
    const html = document.querySelector('html');
    localStorage.setItem('theme', theme);

    if (theme === 'light') {
      html.classList.remove('dark');
      document.querySelector('.theme-icon.light').style.display = 'none';
      document.querySelector('.theme-icon.dark').style.display = 'block';
    } else {
      html.classList.add('dark');
      document.querySelector('.theme-icon.dark').style.display = 'none';
      document.querySelector('.theme-icon.light').style.display = 'block';
    }
  }

  function toggleTheme() {
    const theme = localStorage.getItem('theme');
    const newTheme = theme === 'light' ? 'dark' : 'light';
    localStorage.setItem('theme', newTheme);
    setTheme(newTheme);
    reloadGiscus(newTheme);
  }

  function reloadGiscus(theme) {
    const existingGiscusScript = document.getElementById('giscus-script');
    if (existingGiscusScript) existingGiscusScript.remove();

    let giscusScript = document.createElement('script');
    const giscusTheme = theme === 'light' ? 'noborder_light' : 'noborder_dark';

    let giscusAttributes = {
      id: 'giscus-script',
      src: 'https://giscus.app/client.js',
      'data-repo': 'wiliamvj\/wiliamvj.com',
      'data-repo-id': 'R_kgDOLkkfgA',
      'data-category': 'General',
      'data-category-id': 'DIC_kwDOLkkfgM4CeL5M',
      'data-mapping': 'title',
      'data-strict': '0',
      'data-reactions-enabled':
        '1',
      'data-emit-metadata':
        '0',
      'data-input-position':
        'top',
      'data-theme': giscusTheme,
      'data-lang': 'pt',
      'data-loading': 'lazy',
      crossorigin: 'anonymous',
      async: '',
    };

    Object.entries(giscusAttributes).forEach(([key, value]) =>
      giscusScript.setAttribute(key, value)
    );
    document.body.appendChild(giscusScript);
  }
</script>
</li>
  </ul>
</nav>

  </div>
</header>

      <div class="lg:inline-block hidden">
        <button
  class="toggle-theme"
  aria-label="Toggle Theme"
  title="Toggle Theme"
  onclick="toggleTheme()"
>
  <span class="theme-icon light hidden dark:block">
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
    <path stroke-linecap="round" stroke-linejoin="round" d="M12 3v2.25m6.364.386l-1.591 1.591M21 12h-2.25m-.386 6.364l-1.591-1.591M12 18.75V21m-4.773-4.227l-1.591 1.591M5.25 12H3m4.227-4.773L5.636 5.636M15.75 12a3.75 3.75 0 11-7.5 0 3.75 3.75 0 017.5 0z" />
</svg>
  </span>
  <span class="theme-icon dark block dark:hidden">
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
    <path stroke-linecap="round" stroke-linejoin="round" d="M21.752 15.002A9.718 9.718 0 0118 15.75c-5.385 0-9.75-4.365-9.75-9.75 0-1.33.266-2.597.748-3.752A9.753 9.753 0 003 11.25C3 16.635 7.365 21 12.75 21a9.753 9.753 0 009.002-5.998z" />
</svg>
  </span>
</button>

<script>
  document.addEventListener('DOMContentLoaded', function () {
    const theme = localStorage.getItem('theme');
    setTheme(theme);
  });

  function setTheme(theme) {
    const html = document.querySelector('html');
    localStorage.setItem('theme', theme);

    if (theme === 'light') {
      html.classList.remove('dark');
      document.querySelector('.theme-icon.light').style.display = 'none';
      document.querySelector('.theme-icon.dark').style.display = 'block';
    } else {
      html.classList.add('dark');
      document.querySelector('.theme-icon.dark').style.display = 'none';
      document.querySelector('.theme-icon.light').style.display = 'block';
    }
  }

  function toggleTheme() {
    const theme = localStorage.getItem('theme');
    const newTheme = theme === 'light' ? 'dark' : 'light';
    localStorage.setItem('theme', newTheme);
    setTheme(newTheme);
    reloadGiscus(newTheme);
  }

  function reloadGiscus(theme) {
    const existingGiscusScript = document.getElementById('giscus-script');
    if (existingGiscusScript) existingGiscusScript.remove();

    let giscusScript = document.createElement('script');
    const giscusTheme = theme === 'light' ? 'noborder_light' : 'noborder_dark';

    let giscusAttributes = {
      id: 'giscus-script',
      src: 'https://giscus.app/client.js',
      'data-repo': 'wiliamvj\/wiliamvj.com',
      'data-repo-id': 'R_kgDOLkkfgA',
      'data-category': 'General',
      'data-category-id': 'DIC_kwDOLkkfgM4CeL5M',
      'data-mapping': 'title',
      'data-strict': '0',
      'data-reactions-enabled':
        '1',
      'data-emit-metadata':
        '0',
      'data-input-position':
        'top',
      'data-theme': giscusTheme,
      'data-lang': 'pt',
      'data-loading': 'lazy',
      crossorigin: 'anonymous',
      async: '',
    };

    Object.entries(giscusAttributes).forEach(([key, value]) =>
      giscusScript.setAttribute(key, value)
    );
    document.body.appendChild(giscusScript);
  }
</script>

      </div>
    </div>

    <main id="content">

<article class="flex flex-col gap-10">
  <header class="flex flex-col gap-2">
    <h2 class="title-small">Tenha controle sobre seu SQL com Golang e SQLC</h2>

    <div class="meta">
      
      <time
        datetime="2023-11-25 17:11:00 -0300 -03"
        title='Sat, Nov 25, 2023, 5:11 PM -03'
      >
        Publicado em: 25/11/2023 - 12 minutos de leitura
      </time>

       
    </div>
  </header>

  


  <section><p><img alt="thumbnail" src="/posts/golang-sqlc/dfgU78Lpfdg34.png"></p>
<h2 id="introdução">Introdução</h2>
<p>Lidar com o SQL muitas vezes se torna complicado e cansativo, lidar com tantas queries, indexações, performance, segurança, transações e tudo que envolve o uso do SQL, pensando nisso cada vez mais é adotado o uso de ORM, visando facilitar nossas vidas.</p>
<p>O Uso de ORM geralmente é recomendado devido sua a praticidade de uso, agilidade, entrega de queries mais seguras e rápidas (nem sempre), porém nem tudo é perfeito, o uso de ORM acaba nos limitando quando é preciso fazer uma query mais complexa, a grande maioria dos ORM não oferecem uma boa performance com queries complexas ou até mesmo não tem suporte, precisando então usar SQL no próprio ORM.</p>
<p>Em GO, a comunidade desencoraja o uso de ORM, apesar do <a href="https://gorm.io/">GORM</a> ser um excelente ORM, o uso dele pode sim fazer sentido em pequenas aplicações que não necessitam de uma query mais complexa.</p>
<h2 id="o-usar-em-go-então">O usar em Go então?</h2>
<p>Podemos usar o <a href="https://gorm.io/">GORM</a>, como mencionei, podemos fazer nossas queries e usar apenas o driver do banco de dados, como o <a href="github.com/lib/pq">pq</a> para PostgreSQL (é a opção mais trabalhosa, porém com controle total), mas como o intuito do post é falar sobre o SQLC, vamos usar ele.</p>
<h2 id="o-que-é-o-sqlc">O que é o SQLC?</h2>
<p><a href="https://sqlc.dev/">SQLC</a> é um pacote para facilitar a execução e manipulação das nossas consultas ao banco, ele gera o código automaticamente de acordo com a query SQL que escrevemos.</p>
<p>O SQLC faz a parte mais chata para nós, que é receber os dados do banco e passar para nossa struct por exemplo, e já gera as interfaces para nós.</p>
<p>Pode parecer estranho, vai gerar código GO? Não deve ser bom, eu pensava da mesma forma, até utilizar.</p>
<h2 id="instalando-o-sqlc">Instalando o SQLC</h2>
<p>Precisamos instalar o SQLC na nossa máquina, mas como qualquer pacote em GO, é bem simples, veja como nas <a href="https://docs.sqlc.dev/en/stable/overview/install.html">docs</a>, lembrando que por enquanto o SQLC tem suporte apenas a PostgreSQL, MySQL e SQLite.</p>
<h2 id="criando-o-projeto">Criando o projeto</h2>
<p>Vamos ao código, para isso vamos criar um projeto simples:</p>
<p><img alt="Project structure" src="/posts/golang-sqlc/fgh67hjksfdR65hUioPo.png"></p>
<p>Vamos apenas ter nosso <code>main.go</code>, que vai iniciar a conexão com o banco PostgreSQL e fazer nossa aplicação rodar:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>  <span style="color:#ff79c6">package</span> main
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;database/sql&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;log&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;os&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;github.com/joho/godotenv&#34;</span>
</span></span><span style="display:flex;"><span>    _ <span style="color:#f1fa8c">&#34;github.com/lib/pq&#34;</span>
</span></span><span style="display:flex;"><span>  )
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// load .env file
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    godotenv.<span style="color:#50fa7b">Load</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    postgresURI <span style="color:#ff79c6">:=</span> os.<span style="color:#50fa7b">Getenv</span>(<span style="color:#f1fa8c">&#34;DATABASE_URL&#34;</span>)
</span></span><span style="display:flex;"><span>    db, err <span style="color:#ff79c6">:=</span> sql.<span style="color:#50fa7b">Open</span>(<span style="color:#f1fa8c">&#34;postgres&#34;</span>, postgresURI)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>      log.<span style="color:#50fa7b">Panic</span>(err)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    err = db.<span style="color:#50fa7b">Ping</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>      db.<span style="color:#50fa7b">Close</span>()
</span></span><span style="display:flex;"><span>      log.<span style="color:#50fa7b">Panic</span>(err)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    fmt.<span style="color:#50fa7b">Println</span>(<span style="color:#f1fa8c">&#34;Connected to database&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// keep the program running
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">select</span> {}
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></div><p>Na pasta <strong>internal/database</strong>, no arquivo <code>queries.sql</code> vai ser onde vamos deixar nossas queries.
Na pasta <strong>internal/database/migrations</strong>, vamos deixar a migration que vai criar as nossas tabelas, já fiz um post de como usar o golang-migrate, veja <a href="https://wiliamvj.com/posts/migrations-golang/">aqui</a>{: .normal }.</p>
<p>Para rodar as migrations, verifique se o seu banco PostgreSQL está rodando na porta <code>5432</code> (vou deixar um arquivo <code>docker-compose</code> no repositório), depois rode a migration com:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>  make migrate_up
</span></span></code></pre></div><p>para desfazer a migration rode:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>  make migrate_down
</span></span></code></pre></div><h2 id="executando-o-sqlc">Executando o SQLC</h2>
<p>Finalmente, vamos gerar nossa query e rodar o SQLC, mas antes só verifique se está realmente instalando o SQLC na sua máquina com o comando</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>  sqlc version
</span></span></code></pre></div><p>Se receber uma versão <code>v1.20.0</code> por exemplo, está tudo certo (não precisa ser a mesma versão do exemplo).</p>
<p>Precisamos antes criar um arquivo de config do SLQC, chamado <code>sqlc.yaml</code> na raiz do projeto, nele vamos definir o banco que vamos usar, caminho das pastas e outras configs.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#ff79c6">version</span>: <span style="color:#f1fa8c">&#39;2&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">sql</span>:
</span></span><span style="display:flex;"><span>  - <span style="color:#ff79c6">schema</span>: <span style="color:#f1fa8c">&#39;internal/database/migrations&#39;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">queries</span>: <span style="color:#f1fa8c">&#39;internal/database/queries&#39;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">engine</span>: <span style="color:#f1fa8c">&#39;postgresql&#39;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">gen</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">go</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">package</span>: <span style="color:#f1fa8c">&#39;db&#39;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">out</span>: <span style="color:#f1fa8c">&#39;internal/database/db&#39;</span>
</span></span></code></pre></div><ul>
<li><code>schema</code>: onde fica nosso arquivo da estrutura da nossa tabela no banco de dados.</li>
<li><code>queries</code>: Pasta com as queries que vamos criar.</li>
<li><code>out</code>: Aqui é onde o SQLC vai gerar seu código.</li>
</ul>
<p>Vamos criar uma query chamada <code>user.sql</code> que adiciona um usuário no banco, veja como fica usando o SQLC:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span>  <span style="color:#6272a4">-- name: CreateOneUser :exec
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#ff79c6">INSERT</span> <span style="color:#ff79c6">INTO</span> users (id, name, email, password, created_at, updated_at)
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">VALUES</span> ($<span style="color:#bd93f9">1</span>, $<span style="color:#bd93f9">2</span>, $<span style="color:#bd93f9">3</span>, $<span style="color:#bd93f9">4</span>, $<span style="color:#bd93f9">5</span>, $<span style="color:#bd93f9">6</span>);
</span></span></code></pre></div><p>O SQLC utiliza anotações para as queries, veja:</p>
<ul>
<li><code>--name</code>: Indica o nome da query, será usado como o nome da interface.</li>
<li><code>exec</code>: Indica que queremos executar a query, existem várias, veja <a href="https://docs.sqlc.dev/en/stable/reference/query-annotations.html">aqui</a> nas docs.</li>
</ul>
<p>Vamos criar os arquivos com o comando do SQLC:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>  sqlc generate
</span></span></code></pre></div><p>Você vai perceber que vai ser gerado uma basta chamada <strong>db</strong> dentro da pasta <strong>database</strong>, essa pasta é de uso exclusivo do SQLC e não deve ser alterada.</p>
<p>O SQLC criou 3 arquivos, vamos ver eles:</p>
<p><code>db.go</code>: Aqui é onde o SQLC lida com a conexão do banco, transactions e as queries.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>  <span style="color:#8be9fd;font-style:italic">type</span> DBTX <span style="color:#8be9fd;font-style:italic">interface</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#50fa7b">ExecContext</span>(context.Context, <span style="color:#8be9fd">string</span>, <span style="color:#ff79c6">...</span><span style="color:#8be9fd;font-style:italic">interface</span>{}) (sql.Result, <span style="color:#8be9fd">error</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#50fa7b">PrepareContext</span>(context.Context, <span style="color:#8be9fd">string</span>) (<span style="color:#ff79c6">*</span>sql.Stmt, <span style="color:#8be9fd">error</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#50fa7b">QueryContext</span>(context.Context, <span style="color:#8be9fd">string</span>, <span style="color:#ff79c6">...</span><span style="color:#8be9fd;font-style:italic">interface</span>{}) (<span style="color:#ff79c6">*</span>sql.Rows, <span style="color:#8be9fd">error</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#50fa7b">QueryRowContext</span>(context.Context, <span style="color:#8be9fd">string</span>, <span style="color:#ff79c6">...</span><span style="color:#8be9fd;font-style:italic">interface</span>{}) <span style="color:#ff79c6">*</span>sql.Row
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">New</span>(db DBTX) <span style="color:#ff79c6">*</span>Queries {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">&amp;</span>Queries{db: db}
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#8be9fd;font-style:italic">type</span> Queries <span style="color:#8be9fd;font-style:italic">struct</span> {
</span></span><span style="display:flex;"><span>    db DBTX
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#8be9fd;font-style:italic">func</span> (q <span style="color:#ff79c6">*</span>Queries) <span style="color:#50fa7b">WithTx</span>(tx <span style="color:#ff79c6">*</span>sql.Tx) <span style="color:#ff79c6">*</span>Queries {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">&amp;</span>Queries{
</span></span><span style="display:flex;"><span>      db: tx,
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></div><p><code>models.go</code>: Aqui é onde o SQLC cria os nossos models, de acordo com a estrutura do nosso banco.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>  <span style="color:#8be9fd;font-style:italic">type</span> Post <span style="color:#8be9fd;font-style:italic">struct</span> {
</span></span><span style="display:flex;"><span>    ID        <span style="color:#8be9fd">string</span>
</span></span><span style="display:flex;"><span>    AuthorID  <span style="color:#8be9fd">string</span>
</span></span><span style="display:flex;"><span>    Title     <span style="color:#8be9fd">string</span>
</span></span><span style="display:flex;"><span>    Body      <span style="color:#8be9fd">string</span>
</span></span><span style="display:flex;"><span>    CreatedAt time.Time
</span></span><span style="display:flex;"><span>    UpdatedAt time.Time
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#8be9fd;font-style:italic">type</span> User <span style="color:#8be9fd;font-style:italic">struct</span> {
</span></span><span style="display:flex;"><span>    ID        <span style="color:#8be9fd">string</span>
</span></span><span style="display:flex;"><span>    Name      <span style="color:#8be9fd">string</span>
</span></span><span style="display:flex;"><span>    Email     <span style="color:#8be9fd">string</span>
</span></span><span style="display:flex;"><span>    Password  <span style="color:#8be9fd">string</span>
</span></span><span style="display:flex;"><span>    CreatedAt time.Time
</span></span><span style="display:flex;"><span>    UpdatedAt time.Time
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></div><p><code>user.sql.go</code>: Aqui é onde o SQLC cria as funções que vamos executar e nossas structs para envio dos parâmetros:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>  <span style="color:#8be9fd;font-style:italic">const</span> createOneUser = <span style="color:#f1fa8c">`-- name: CreateOneUser :exec
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">  INSERT INTO users (id, name, email, password, created_at, updated_at)
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">  VALUES ($1, $2, $3, $4, $5, $6)
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">  `</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#8be9fd;font-style:italic">type</span> CreateOneUserParams <span style="color:#8be9fd;font-style:italic">struct</span> {
</span></span><span style="display:flex;"><span>    ID        <span style="color:#8be9fd">string</span>
</span></span><span style="display:flex;"><span>    Name      <span style="color:#8be9fd">string</span>
</span></span><span style="display:flex;"><span>    Email     <span style="color:#8be9fd">string</span>
</span></span><span style="display:flex;"><span>    Password  <span style="color:#8be9fd">string</span>
</span></span><span style="display:flex;"><span>    CreatedAt time.Time
</span></span><span style="display:flex;"><span>    UpdatedAt time.Time
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#8be9fd;font-style:italic">func</span> (q <span style="color:#ff79c6">*</span>Queries) <span style="color:#50fa7b">CreateOneUser</span>(ctx context.Context, arg CreateOneUserParams) <span style="color:#8be9fd">error</span> {
</span></span><span style="display:flex;"><span>    _, err <span style="color:#ff79c6">:=</span> q.db.<span style="color:#50fa7b">ExecContext</span>(ctx, createOneUser,
</span></span><span style="display:flex;"><span>      arg.ID,
</span></span><span style="display:flex;"><span>      arg.Name,
</span></span><span style="display:flex;"><span>      arg.Email,
</span></span><span style="display:flex;"><span>      arg.Password,
</span></span><span style="display:flex;"><span>      arg.CreatedAt,
</span></span><span style="display:flex;"><span>      arg.UpdatedAt,
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> err
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></div><p>O SQLC também deixa a query que vai ser executada, no nosso caso em <code>createOneUser</code>.</p>
<h2 id="criando-um-registro-com-sqlc">Criando um registro com SQLC</h2>
<p>Vamos salvar um usuário com uso do SQLC, no nosso caso vamos salvar o usuário quando iniciar nossa aplicação, mas em uso real, seria criado quando receber uma requisição <code>POST</code> de um controller por exemplo.</p>
<p>Vamos criar dentro da pasta <strong>internal</strong>, uma pasta chamada <strong>handler</strong> e o arquivo chamado <code>user.go</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>  <span style="color:#ff79c6">package</span> handler
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;context&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;time&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;github.com/google/uuid&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;github.com/wiliamvj/golang-sqlc/internal/database/db&#34;</span>
</span></span><span style="display:flex;"><span>  )
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#8be9fd;font-style:italic">type</span> UserHandler <span style="color:#8be9fd;font-style:italic">struct</span> {
</span></span><span style="display:flex;"><span>    Queries <span style="color:#ff79c6">*</span>db.Queries
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">CreateUser</span>(ctx context.Context, h <span style="color:#ff79c6">*</span>UserHandler) <span style="color:#8be9fd">error</span> {
</span></span><span style="display:flex;"><span>    err <span style="color:#ff79c6">:=</span> h.Queries.<span style="color:#50fa7b">CreateOneUser</span>(ctx, db.CreateOneUserParams{
</span></span><span style="display:flex;"><span>      ID:        uuid.<span style="color:#50fa7b">New</span>().<span style="color:#50fa7b">String</span>(),
</span></span><span style="display:flex;"><span>      Name:      <span style="color:#f1fa8c">&#34;John Doe&#34;</span>,
</span></span><span style="display:flex;"><span>      Email:     <span style="color:#f1fa8c">&#34;john.doe@email.com&#34;</span>,
</span></span><span style="display:flex;"><span>      Password:  <span style="color:#f1fa8c">&#34;123456&#34;</span>,
</span></span><span style="display:flex;"><span>      CreatedAt: time.<span style="color:#50fa7b">Now</span>(),
</span></span><span style="display:flex;"><span>      UpdatedAt: time.<span style="color:#50fa7b">Now</span>(),
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>      fmt.<span style="color:#50fa7b">Println</span>(<span style="color:#f1fa8c">&#34;Error creating user&#34;</span>, err)
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">return</span> err
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    fmt.<span style="color:#50fa7b">Println</span>(<span style="color:#f1fa8c">&#34;User created&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></div><p>Criamos uma struct, que vai receber um ponteiro das queries criadas pelo SQLC, depois usamos a função <code>CreateOneUser</code> criada pelo SQLC e passamos os parâmetros esperados, isso é o suficiente para salvar no banco, vamos agora chamar o <code>CreateUser</code> no <code>main.go</code>, simulando uma requisição.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>   <span style="color:#6272a4">// start slqc queries
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  slqcQueries <span style="color:#ff79c6">:=</span> db.<span style="color:#50fa7b">New</span>(dbConnection)
</span></span><span style="display:flex;"><span>  q <span style="color:#ff79c6">:=</span> handler.UserHandler{
</span></span><span style="display:flex;"><span>    Queries: slqcQueries,
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  handler.<span style="color:#50fa7b">CreateUser</span>(context.<span style="color:#50fa7b">Background</span>(), <span style="color:#ff79c6">&amp;</span>q)
</span></span></code></pre></div><p>Iniciamos no SQLC passando para o <code>db.New</code> a conexão com o banco, depois iniciamos a struct <code>UserHandler</code> e por fim chamamos a função <code>CreateUser</code>.</p>
<p><code>main.go</code> completo:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>  <span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// load .env file
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    godotenv.<span style="color:#50fa7b">Load</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    postgresURI <span style="color:#ff79c6">:=</span> os.<span style="color:#50fa7b">Getenv</span>(<span style="color:#f1fa8c">&#34;DATABASE_URL&#34;</span>)
</span></span><span style="display:flex;"><span>    dbConnection, err <span style="color:#ff79c6">:=</span> sql.<span style="color:#50fa7b">Open</span>(<span style="color:#f1fa8c">&#34;postgres&#34;</span>, postgresURI)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>      log.<span style="color:#50fa7b">Panic</span>(err)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    err = dbConnection.<span style="color:#50fa7b">Ping</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>      dbConnection.<span style="color:#50fa7b">Close</span>()
</span></span><span style="display:flex;"><span>      log.<span style="color:#50fa7b">Panic</span>(err)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    fmt.<span style="color:#50fa7b">Println</span>(<span style="color:#f1fa8c">&#34;Connected to database&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// start slqc queries
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    slqcQueries <span style="color:#ff79c6">:=</span> db.<span style="color:#50fa7b">New</span>(dbConnection)
</span></span><span style="display:flex;"><span>    q <span style="color:#ff79c6">:=</span> handler.UserHandler{
</span></span><span style="display:flex;"><span>      Queries: slqcQueries,
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    handler.<span style="color:#50fa7b">CreateUser</span>(context.<span style="color:#50fa7b">Background</span>(), <span style="color:#ff79c6">&amp;</span>q)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// keep the program running
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">select</span> {}
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></div><p>Agora se iniciar a aplicação, vamos receber o log <code>User created</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>  Connected to database
</span></span><span style="display:flex;"><span>  User created
</span></span></code></pre></div><p>Se tentar rodar novamente, vamos receber um erro, isso porque nosso e-mail é único no banco, e já existe, o correto é antes de salvar no banco, verificar se já existe um registro com o mesmo e-mail, mas não vamos fazer isso por enquanto.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>  Connected to database
</span></span><span style="display:flex;"><span>  Error creating user pq: duplicate key value violates unique constraint <span style="color:#f1fa8c">&#34;users_email_key&#34;</span>
</span></span></code></pre></div><p>Agora, vamos salvar nosso post, vamos criar o usuário e logo em seguida criar o post, vamos fazer isso para exemplificar um problema que vamos enfrentar:</p>
<p>Criando query <code>post.sql</code>na pasta <strong>queries</strong> para salvar o post:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span>  <span style="color:#6272a4">-- name: CreateOnePost :exec
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#ff79c6">INSERT</span> <span style="color:#ff79c6">INTO</span> posts (id, title, body, author_id, created_at, updated_at)
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">VALUES</span> ($<span style="color:#bd93f9">1</span>, $<span style="color:#bd93f9">2</span>, $<span style="color:#bd93f9">3</span>, $<span style="color:#bd93f9">4</span>, $<span style="color:#bd93f9">5</span>, $<span style="color:#bd93f9">6</span>);
</span></span></code></pre></div><p>Vamos rodar novamente o comando do sqlc para atualizar os arquivos:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>  sqlc generate
</span></span></code></pre></div><p>Com os arquivos atualizados, vamos criar o post dentro do <code>user.go</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>  <span style="color:#8be9fd;font-style:italic">type</span> UserHandler <span style="color:#8be9fd;font-style:italic">struct</span> {
</span></span><span style="display:flex;"><span>    Queries <span style="color:#ff79c6">*</span>db.Queries
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">CreateUser</span>(ctx context.Context, h <span style="color:#ff79c6">*</span>UserHandler) <span style="color:#8be9fd">error</span> {
</span></span><span style="display:flex;"><span>    userID <span style="color:#ff79c6">:=</span> uuid.<span style="color:#50fa7b">New</span>().<span style="color:#50fa7b">String</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    err <span style="color:#ff79c6">:=</span> h.Queries.<span style="color:#50fa7b">CreateOneUser</span>(ctx, db.CreateOneUserParams{
</span></span><span style="display:flex;"><span>      ID:        userID,
</span></span><span style="display:flex;"><span>      Name:      <span style="color:#f1fa8c">&#34;John Doe&#34;</span>,
</span></span><span style="display:flex;"><span>      Email:     <span style="color:#f1fa8c">&#34;john.doe@email.com&#34;</span>,
</span></span><span style="display:flex;"><span>      Password:  <span style="color:#f1fa8c">&#34;123456&#34;</span>,
</span></span><span style="display:flex;"><span>      CreatedAt: time.<span style="color:#50fa7b">Now</span>(),
</span></span><span style="display:flex;"><span>      UpdatedAt: time.<span style="color:#50fa7b">Now</span>(),
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>      fmt.<span style="color:#50fa7b">Println</span>(<span style="color:#f1fa8c">&#34;Error creating user&#34;</span>, err)
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">return</span> err
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    fmt.<span style="color:#50fa7b">Println</span>(<span style="color:#f1fa8c">&#34;User created&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// create post
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    err = h.Queries.<span style="color:#50fa7b">CreateOnePost</span>(ctx, db.CreateOnePostParams{
</span></span><span style="display:flex;"><span>      ID:        uuid.<span style="color:#50fa7b">New</span>().<span style="color:#50fa7b">String</span>(),
</span></span><span style="display:flex;"><span>      Title:     <span style="color:#f1fa8c">&#34;SLQC with Golang&#34;</span>,
</span></span><span style="display:flex;"><span>      Body:      <span style="color:#f1fa8c">&#34;This is a post about SLQC with Golang&#34;</span>,
</span></span><span style="display:flex;"><span>      AuthorID:  userID,
</span></span><span style="display:flex;"><span>      CreatedAt: time.<span style="color:#50fa7b">Now</span>(),
</span></span><span style="display:flex;"><span>      UpdatedAt: time.<span style="color:#50fa7b">Now</span>(),
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>      fmt.<span style="color:#50fa7b">Println</span>(<span style="color:#f1fa8c">&#34;Error creating post&#34;</span>, err)
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">return</span> err
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    fmt.<span style="color:#50fa7b">Println</span>(<span style="color:#f1fa8c">&#34;Post created&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></div><p>Fizemos o mesmo processo ao salvar o usuário, mas perceba que separei o id do usuário en uma variável chamada <code>userID</code>, pois precisamos do id para salvar o post, uma vez que temos um relacionamento one-to-many, onde um usuário pode ter muitos posts e um post tem apenas 1 usuário, é apenas um exemplo.</p>
<p>Ao rodar o projeto novamente, vamos ter sucesso ao salvar o usuário e o post, mas antes lembre-se de apagar todos os registros, como não validamos se já existe registros de usuário com mesmo e-mail, vai dar erro.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>  Connected to database
</span></span><span style="display:flex;"><span>  User created
</span></span><span style="display:flex;"><span>  Post created
</span></span></code></pre></div><p>Nosso usuário e nosso post foram criados com sucesso, porém quando criamos registros em &ldquo;cascata&rdquo;, se um deles falhar por algum motivo os demais ainda podem ser criados, vamos ver como resolver isso com transactions.</p>
<h2 id="transactions">Transactions</h2>
<p>As transactions são um conjunto de operações que são tratadas como uma única operação, no nosso exemplo ao criar um usuário em seguida já criamos um post, as duas operações depende uma da outra, então usamos as transações.</p>
<p>Uma transação só pode ter sucesso ou falhar, se tiver sucesso, salvamos todos os registros, em nosso exemplo será criado um usuário e um post, mas se falhar, não será criado nenhum registros, caso a criação do post falhe, será feito um <code>rollback</code> nas operações anteriores, ou seja o usuário não será salvo. Isso garante que todas as operações realizadas sejam escritas com sucesso, mas se falhar nenhuma operação é salva.</p>
<p>O SQLC nos permite trabalhar com isso, vamos a um exemplo, imagine que sempre que criar um usuário seja obrigatório criar um post, mas e se a criação do post falhar? Vamos alterar o <code>user.go</code>, forçando um erro, vamos sempre tentar salvar um post com o mesmo <code>id</code>, na segunda tentativa já vai falar, pois teremos no banco um registro com o mesmo <code>id</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>  <span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">CreateUser</span>(ctx context.Context, h <span style="color:#ff79c6">*</span>UserHandler) <span style="color:#8be9fd">error</span> {
</span></span><span style="display:flex;"><span>    userID <span style="color:#ff79c6">:=</span> uuid.<span style="color:#50fa7b">New</span>().<span style="color:#50fa7b">String</span>()
</span></span><span style="display:flex;"><span>    userEmail <span style="color:#ff79c6">:=</span> fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;john.doe-%v@email.com&#34;</span>, time.<span style="color:#50fa7b">Now</span>().<span style="color:#50fa7b">Unix</span>())
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    err <span style="color:#ff79c6">:=</span> h.Queries.<span style="color:#50fa7b">CreateOneUser</span>(ctx, db.CreateOneUserParams{
</span></span><span style="display:flex;"><span>      ID:        userID,
</span></span><span style="display:flex;"><span>      Name:      <span style="color:#f1fa8c">&#34;John Doe&#34;</span>,
</span></span><span style="display:flex;"><span>      Email:     userEmail,
</span></span><span style="display:flex;"><span>      Password:  <span style="color:#f1fa8c">&#34;123456&#34;</span>,
</span></span><span style="display:flex;"><span>      CreatedAt: time.<span style="color:#50fa7b">Now</span>(),
</span></span><span style="display:flex;"><span>      UpdatedAt: time.<span style="color:#50fa7b">Now</span>(),
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>      fmt.<span style="color:#50fa7b">Println</span>(<span style="color:#f1fa8c">&#34;Error creating user&#34;</span>, err)
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">return</span> err
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    fmt.<span style="color:#50fa7b">Println</span>(<span style="color:#f1fa8c">&#34;User created&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// create post
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    err = h.Queries.<span style="color:#50fa7b">CreateOnePost</span>(ctx, db.CreateOnePostParams{
</span></span><span style="display:flex;"><span>      ID:        <span style="color:#f1fa8c">&#34;093eb8c7-d09d-464d-aa55-99ee7c1b7488&#34;</span>,
</span></span><span style="display:flex;"><span>      Title:     <span style="color:#f1fa8c">&#34;SLQC with Golang&#34;</span>,
</span></span><span style="display:flex;"><span>      Body:      <span style="color:#f1fa8c">&#34;This is a post about SLQC with Golang&#34;</span>,
</span></span><span style="display:flex;"><span>      AuthorID:  userID,
</span></span><span style="display:flex;"><span>      CreatedAt: time.<span style="color:#50fa7b">Now</span>(),
</span></span><span style="display:flex;"><span>      UpdatedAt: time.<span style="color:#50fa7b">Now</span>(),
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>      fmt.<span style="color:#50fa7b">Println</span>(<span style="color:#f1fa8c">&#34;Error creating post&#34;</span>, err)
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">return</span> err
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    fmt.<span style="color:#50fa7b">Println</span>(<span style="color:#f1fa8c">&#34;Post created&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></div><p>Deixamos o <code>id</code> do post sempre o mesmo, também coloquei o <code>userEmail</code> para gerar um e-mail único sempre que iniciar nossa aplicação, recebemos o erro na segunda tentativa:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>  Connected to database
</span></span><span style="display:flex;"><span>  User created
</span></span><span style="display:flex;"><span>  Error creating post pq: duplicate key value violates unique constraint <span style="color:#f1fa8c">&#34;posts_pkey&#34;</span>
</span></span></code></pre></div><p>Mas se você perceber na tabela <code>users</code> o usuário é sempre criado, vamos então usar transactions.</p>
<h2 id="utilizando-transactions-com-sqlc">Utilizando transactions com SQLC</h2>
<p>Para utilizar transactions, vamos injetar uma função no SQLX que executa nossa queries, ficando assim:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>  <span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">runWithTX</span>(ctx context.Context, c <span style="color:#ff79c6">*</span>sql.DB, fn <span style="color:#8be9fd;font-style:italic">func</span>(<span style="color:#ff79c6">*</span>db.Queries) <span style="color:#8be9fd">error</span>) <span style="color:#8be9fd">error</span> {
</span></span><span style="display:flex;"><span>    tx, err <span style="color:#ff79c6">:=</span> c.<span style="color:#50fa7b">BeginTx</span>(ctx, <span style="color:#ff79c6">nil</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">return</span> err
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    q <span style="color:#ff79c6">:=</span> db.<span style="color:#50fa7b">New</span>(tx)
</span></span><span style="display:flex;"><span>    err = <span style="color:#50fa7b">fn</span>(q)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">if</span> errRb <span style="color:#ff79c6">:=</span> tx.<span style="color:#50fa7b">Rollback</span>(); errRb <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">return</span> fmt.<span style="color:#50fa7b">Errorf</span>(<span style="color:#f1fa8c">&#34;error on rollback: %v, original error: %w&#34;</span>, errRb, err)
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">return</span> err
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> tx.<span style="color:#50fa7b">Commit</span>()
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></div><p>Essa função vai ser a que vamos usar para executar as queries com transactions, passamos a conexão com o banco, iniciamos a conexão com transaction com <code>BeginTx</code>, passando o contexto e <code>nil</code>, o <code>nil</code> é referente <em>isolation level</em> (não vamos abordar no momento, mas veja <a href="https://www.postgresql.org/docs/current/transaction-iso.html">aqui</a> do que se trata, iniciamos o <code>db.New(tx)</code>, conforme já vimos, mas agora usando transactions, depois executamos nossa query, se der erro fazemos <code>tx.Rollback()</code>, se não houver erro <code>tx.Commit()</code> finalizando tudo.</p>
<p>Para isso funcionar, precisamos atualizar a função <code>CreateUser</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>  <span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">CreateUser</span>(ctx context.Context, h <span style="color:#ff79c6">*</span>UserHandler) <span style="color:#8be9fd">error</span> {
</span></span><span style="display:flex;"><span>    userID <span style="color:#ff79c6">:=</span> uuid.<span style="color:#50fa7b">New</span>().<span style="color:#50fa7b">String</span>()
</span></span><span style="display:flex;"><span>    userEmail <span style="color:#ff79c6">:=</span> fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;john.doe-%v@email.com&#34;</span>, time.<span style="color:#50fa7b">Now</span>().<span style="color:#50fa7b">Unix</span>())
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    err <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">runWithTX</span>(ctx, h.Db, <span style="color:#8be9fd;font-style:italic">func</span>(q <span style="color:#ff79c6">*</span>db.Queries) <span style="color:#8be9fd">error</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#8be9fd;font-style:italic">var</span> err <span style="color:#8be9fd">error</span>
</span></span><span style="display:flex;"><span>      err = q.<span style="color:#50fa7b">CreateOneUser</span>(ctx, db.CreateOneUserParams{
</span></span><span style="display:flex;"><span>        ID:        userID,
</span></span><span style="display:flex;"><span>        Name:      <span style="color:#f1fa8c">&#34;John Doe&#34;</span>,
</span></span><span style="display:flex;"><span>        Email:     userEmail,
</span></span><span style="display:flex;"><span>        Password:  <span style="color:#f1fa8c">&#34;123456&#34;</span>,
</span></span><span style="display:flex;"><span>        CreatedAt: time.<span style="color:#50fa7b">Now</span>(),
</span></span><span style="display:flex;"><span>        UpdatedAt: time.<span style="color:#50fa7b">Now</span>(),
</span></span><span style="display:flex;"><span>      })
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>        fmt.<span style="color:#50fa7b">Println</span>(<span style="color:#f1fa8c">&#34;Error creating user&#34;</span>, err)
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">return</span> err
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      fmt.<span style="color:#50fa7b">Println</span>(<span style="color:#f1fa8c">&#34;User created&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#6272a4">// create post
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>      err = q.<span style="color:#50fa7b">CreateOnePost</span>(ctx, db.CreateOnePostParams{
</span></span><span style="display:flex;"><span>        ID:        <span style="color:#f1fa8c">&#34;193eb8c7-d09d-464d-aa55-99ee7c1b7488&#34;</span>,
</span></span><span style="display:flex;"><span>        Title:     <span style="color:#f1fa8c">&#34;SLQC with Golang&#34;</span>,
</span></span><span style="display:flex;"><span>        Body:      <span style="color:#f1fa8c">&#34;This is a post about SLQC with Golang&#34;</span>,
</span></span><span style="display:flex;"><span>        AuthorID:  userID,
</span></span><span style="display:flex;"><span>        CreatedAt: time.<span style="color:#50fa7b">Now</span>(),
</span></span><span style="display:flex;"><span>        UpdatedAt: time.<span style="color:#50fa7b">Now</span>(),
</span></span><span style="display:flex;"><span>      })
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>        fmt.<span style="color:#50fa7b">Println</span>(<span style="color:#f1fa8c">&#34;Error creating post&#34;</span>, err)
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">return</span> err
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      fmt.<span style="color:#50fa7b">Println</span>(<span style="color:#f1fa8c">&#34;Post created&#34;</span>)
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>      fmt.<span style="color:#50fa7b">Println</span>(<span style="color:#f1fa8c">&#34;Error creating user and post, roll back applied&#34;</span>, err)
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">return</span> err
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></div><p>Agora utilizamos o <code>runWithTX</code>, e ao usar as queries do sqlc, não usamos mais o <code>h.Queries</code>, usamos o <code>q</code>, que vem da função que injetamos, assim executando utilizando transactions, agora se rodas a aplicação, veja o erro:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>  Connected to database
</span></span><span style="display:flex;"><span>  User created
</span></span><span style="display:flex;"><span>  Error creating post pq: duplicate key value violates unique constraint <span style="color:#f1fa8c">&#34;posts_pkey&#34;</span>
</span></span><span style="display:flex;"><span>  Error creating user and post, roll back applied pq: duplicate key value violates unique constraint <span style="color:#f1fa8c">&#34;posts_pkey&#34;</span>
</span></span></code></pre></div><p>No log <code>creating user and post, roll back applied</code>, pode perceber que a transactions rodou, se olhar no banco, nenhum usuário agora é salvo devido ao erro na criação do post, se remover o <code>id</code> do post que está fixo, e colocar novamente o
<code>uuid.New().String()</code>, e rodar a aplicação, tudo funcionará normalmente.</p>
<p>Abordamos apenas um exemplo simples sobre transactions, é um assunto mais complexo, vou deixar a <a href="https://docs.sqlc.dev/en/stable/howto/transactions.html">documentação</a> do sqlc sobre transactions.</p>
<h2 id="considerações-finais">Considerações finais</h2>
<p>Como podem perceber o uso do sqlc nos possibilita controle total sobre nosso SQL, o sqlc também é bastante simples de utilizar. Se você não quer usar ORM a utilização do sqlc pode ser uma opção, remove o trabalho mais braçal que é ficar transformando dados conhecido como &ldquo;hidratação de dados&rdquo;.</p>
<p>O sqlc tem vários &ldquo;truques&rdquo; que podem facilitar a manipulação de dados como <a href="https://docs.sqlc.dev/en/stable/howto/overrides.html">Overriding types</a>, <a href="https://docs.sqlc.dev/en/stable/howto/named_parameters.html">Naming parameters</a> e muitos outros, vale a pena olhar as docs.</p>
<h2 id="link-do-repositório">Link do repositório</h2>
<p><a href="https://github.com/wiliamvj/golang-sqlc">repositório</a> do projeto</p>
<p><a href="https://github.com/egonelbre/gophers">Gopher credits</a></p>
</section>

  

 <div class="giscus-comment">
  <script>
    let theme = localStorage.getItem('theme');
    const giscusTheme = theme === 'light' ? 'noborder_light' : 'noborder_dark';
    var currentUrl = window.location.href;
    const lang = currentUrl.indexOf('/en/') !== -1 ? 'en' : 'pt';
    let giscusAttributes = {
      id: 'giscus-script',
      src: 'https://giscus.app/client.js',
      'data-repo': 'wiliamvj\/wiliamvj.com',
      'data-repo-id': 'R_kgDOLkkfgA',
      'data-category': 'General',
      'data-category-id': 'DIC_kwDOLkkfgM4CeL5M',
      'data-mapping': 'title',
      'data-strict': '0',
      'data-reactions-enabled':
        '1',
      'data-emit-metadata':
        '0',
      'data-input-position':
        'top',
      'data-theme': theme,
      'data-lang': lang,
      'data-loading': 'lazy',
      crossorigin: 'anonymous',
      async: '',
    };

    let giscusScript = document.createElement('script');
    const article = document.querySelector('article');
    Object.entries(giscusAttributes).forEach(([key, value]) =>
      giscusScript.setAttribute(key, value)
    );
    article.appendChild(giscusScript);
  </script>
</div>
 


 


  <footer>
    
  </footer>
</article>

</main><footer class="pt-5 pb-6 lg:grid lg:gap-3 lg:grid-cols-2">
  <div class="text-xs font-semibold text-gray-500 order-2 sm:order-1">
  © 2024 —
  <a href="//localhost:1313/">Wiliam V. Joaquim</a>
  <span class="font-normal">with</span>
  <a
    href="https://github.com/nixentric/Lowkey-Hugo-Theme"
    target="_blank"
    rel="noopener noreferrer"
  >
    Lowkey
  </a>
</div>
 <div class="order-1 sm:order-2 f-social">
  <ul class="flex sm:justify-end gap-5">
     
    <li>
      <a href="https://www.linkedin.com/in/wiliamvj/" target="_blank" rel="noopener noreferrer"
        >linkedin</a
      >
    </li>
    
    <li>
      <a href="https://twitter.com/wiliamjoaquim" target="_blank" rel="noopener noreferrer"
        >x</a
      >
    </li>
    
    <li>
      <a href="https://github.com/wiliamvj" target="_blank" rel="noopener noreferrer"
        >github</a
      >
    </li>
    
    <li>
      <a href="https://dev.to/wiliamvj" target="_blank" rel="noopener noreferrer"
        >dev.to</a
      >
    </li>
     
  </ul>
</div>

</footer>

<button
  type="button"
  data-twe-ripple-init
  data-twe-ripple-color="light"
  class="!fixed bottom-5 end-5 hidden rounded-md bg-wpurple p-3 text-xs font-medium uppercase leading-tight text-white shadow-md transition duration-150 ease-in-out hover:bg-wpurplehover hover:shadow-lg focus:bg-wpurplehover focus:shadow-lg focus:outline-none focus:ring-0 active:bg-wpurple active:shadow-lg"
  id="btn-back-to-top"
>
  <span class="[&>svg]:w-4">
    <svg
      xmlns="http://www.w3.org/2000/svg"
      fill="none"
      viewBox="0 0 24 24"
      stroke-width="3"
      stroke="currentColor"
    >
      <path
        stroke-linecap="round"
        stroke-linejoin="round"
        d="M4.5 10.5 12 3m0 0 7.5 7.5M12 3v18"
      />
    </svg>
  </span>
</button>

<script defer>
  const mybutton = document.getElementById('btn-back-to-top');
  const scrollFunction = () => {
    if (
      document.body.scrollTop > 20 ||
      document.documentElement.scrollTop > 20
    ) {
      mybutton.classList.remove('hidden');
    } else {
      mybutton.classList.add('hidden');
    }
  };
  const backToTop = () => {
    window.scrollTo({ top: 0, behavior: 'smooth' });
  };

  mybutton.addEventListener('click', backToTop);
  window.addEventListener('scroll', scrollFunction);
</script>
</body>
</html>
