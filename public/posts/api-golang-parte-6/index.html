<!DOCTYPE html>
<html lang="pt" class="scroll-smooth dark">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script> 

<meta charset="UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>API completa em Golang - Parte 6</title>
<meta
  name="apple-mobile-web-app-title"
  content="API completa em Golang - Parte 6"
/>
<meta
  name="description"
  content="O que vamos fazer? Na parte 6 do nosso crud vamos finalizar nosso repository, salvando os dados do usuários no banco de dados utilizando o sqlc."
/>
<link
  rel="apple-touch-icon"
  sizes="180x180"
  href="/icons/apple-touch.png"
/>

<link rel="canonical" href="//localhost:1313/posts/api-golang-parte-6/" />
<link rel="robots" href="/robots.txt" />

<link rel="icon" type="image/x-icon" href="/icons/favicon.ico" />

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });</script>

<link rel="stylesheet" href="//localhost:1313/css/app.css" /></head>

  <body class="max-w-screen-md mx-auto">
    <div class="header">
      <header
  class="flex flex-col sm:flex-row items-center gap-5 sm:gap-10 pt-16 sm:py-12"
>
   


<div class="flex-none w-20 h-20 rounded-full overflow-hidden">
  <a href="//localhost:1313/">
    <img
      srcset="/img/profile-picture_hucbf2afd9e62dc6021c155b0731b41164_625734_80x80_fill_q90_box_smart1.jpg 80w"
      src="/img/profile-picture.jpg"
      width="1080"
      height="1080"
      alt="Wiliam V. Joaquim"
    />
  </a>
</div>


  <div class="flex flex-col gap-5">
    <a href="//localhost:1313/">
  <h1 id="site-title">Wiliam V<span class="text-wpurple">.</span> Joaquim</h1>
</a>
 <nav>
  <ul class="px-4 lg:px-0">
     
    <li>
      <a
        href="/"
        class=""
        
      >
        Artigos
      </a>
      <span class="text-wpurple text-lg">.</span>
    </li>
    
    <li>
      <a
        href="https://wiliamvj.substack.com/"
        class=""
         target="_blank" 
      >
        Newsletter
      </a>
      <span class="text-wpurple text-lg">.</span>
    </li>
    
    <li>
      <a
        href="/en/"
        class=""
        
      >
        en-US
      </a>
      <span class="text-wpurple text-lg">.</span>
    </li>
    
    <li class="-mt-2 block lg:hidden"><button
  class="toggle-theme"
  aria-label="Toggle Theme"
  title="Toggle Theme"
  onclick="toggleTheme()"
>
  <span class="theme-icon light hidden dark:block">
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
    <path stroke-linecap="round" stroke-linejoin="round" d="M12 3v2.25m6.364.386l-1.591 1.591M21 12h-2.25m-.386 6.364l-1.591-1.591M12 18.75V21m-4.773-4.227l-1.591 1.591M5.25 12H3m4.227-4.773L5.636 5.636M15.75 12a3.75 3.75 0 11-7.5 0 3.75 3.75 0 017.5 0z" />
</svg>
  </span>
  <span class="theme-icon dark block dark:hidden">
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
    <path stroke-linecap="round" stroke-linejoin="round" d="M21.752 15.002A9.718 9.718 0 0118 15.75c-5.385 0-9.75-4.365-9.75-9.75 0-1.33.266-2.597.748-3.752A9.753 9.753 0 003 11.25C3 16.635 7.365 21 12.75 21a9.753 9.753 0 009.002-5.998z" />
</svg>
  </span>
</button>

<script>
  document.addEventListener('DOMContentLoaded', function () {
    const theme = localStorage.getItem('theme');

    if (!theme || theme !== 'light') {
      setTheme('dark');
    } else {
      setTheme(theme);
    }
  });

  function setTheme(theme) {
    const html = document.querySelector('html');
    localStorage.setItem('theme', theme);

    if (theme === 'light') {
      if (html.classList.contains('dark')) {
        document.querySelector('html').classList.remove('dark');
      }

      document.querySelector('.theme-icon.light').style.display = 'none';
      document.querySelector('.theme-icon.dark').style.display = 'block';
    } else {
      if (!html.classList.contains('dark')) {
        document.querySelector('html').classList.add('dark');
      }

      document.querySelector('.theme-icon.dark').style.display = 'none';
      document.querySelector('.theme-icon.light').style.display = 'block';
    }
  }

  function toggleTheme() {
    const theme = localStorage.getItem('theme');

    if (theme === 'light') {
      setTheme('dark');
    } else {
      setTheme('light');
    }
  }
</script>
</li>
  </ul>
</nav>

  </div>
</header>

      <div class="lg:inline-block hidden">
        <button
  class="toggle-theme"
  aria-label="Toggle Theme"
  title="Toggle Theme"
  onclick="toggleTheme()"
>
  <span class="theme-icon light hidden dark:block">
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
    <path stroke-linecap="round" stroke-linejoin="round" d="M12 3v2.25m6.364.386l-1.591 1.591M21 12h-2.25m-.386 6.364l-1.591-1.591M12 18.75V21m-4.773-4.227l-1.591 1.591M5.25 12H3m4.227-4.773L5.636 5.636M15.75 12a3.75 3.75 0 11-7.5 0 3.75 3.75 0 017.5 0z" />
</svg>
  </span>
  <span class="theme-icon dark block dark:hidden">
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
    <path stroke-linecap="round" stroke-linejoin="round" d="M21.752 15.002A9.718 9.718 0 0118 15.75c-5.385 0-9.75-4.365-9.75-9.75 0-1.33.266-2.597.748-3.752A9.753 9.753 0 003 11.25C3 16.635 7.365 21 12.75 21a9.753 9.753 0 009.002-5.998z" />
</svg>
  </span>
</button>

<script>
  document.addEventListener('DOMContentLoaded', function () {
    const theme = localStorage.getItem('theme');

    if (!theme || theme !== 'light') {
      setTheme('dark');
    } else {
      setTheme(theme);
    }
  });

  function setTheme(theme) {
    const html = document.querySelector('html');
    localStorage.setItem('theme', theme);

    if (theme === 'light') {
      if (html.classList.contains('dark')) {
        document.querySelector('html').classList.remove('dark');
      }

      document.querySelector('.theme-icon.light').style.display = 'none';
      document.querySelector('.theme-icon.dark').style.display = 'block';
    } else {
      if (!html.classList.contains('dark')) {
        document.querySelector('html').classList.add('dark');
      }

      document.querySelector('.theme-icon.dark').style.display = 'none';
      document.querySelector('.theme-icon.light').style.display = 'block';
    }
  }

  function toggleTheme() {
    const theme = localStorage.getItem('theme');

    if (theme === 'light') {
      setTheme('dark');
    } else {
      setTheme('light');
    }
  }
</script>

      </div>
    </div>

    <main id="content">

<article class="flex flex-col gap-10">
  <header class="flex flex-col gap-2">
    <h2 class="title-small">API completa em Golang - Parte 6</h2>

    <div class="meta">
      
      <time
        datetime="2024-01-23 19:03:34 -0300 -03"
        title='Tue, Jan 23, 2024, 7:03 PM -03'
      >
        Publicado em: 23/01/2024 - 17 minutos de leitura
      </time>

       
    </div>
  </header>

  

  <section><p><img alt="thumbnail" src="/posts/api-golang-parte-6/thumb_re435g5G5gGfgfOp.png"></p>
<h2 id="o-que-vamos-fazer">O que vamos fazer?</h2>
<p>Na parte 6 do nosso crud vamos finalizar nosso repository, salvando os dados do usuários no banco de dados utilizando o <a href="https://sqlc.dev/">sqlc</a>.</p>
<p>Se ainda não viu os posts anteriores leia eles primeiro.</p>
<p><a href="/posts/api-golang-parte-1/">parte 1</a> |
<a href="/posts/api-golang-parte-2/">parte 2</a> |
<a href="/posts/api-golang-parte-3/">parte 3</a> |
<a href="/posts/api-golang-parte-4/">parte 4</a> |
<a href="/posts/api-golang-parte-5/">parte 5</a> |</p>
<h2 id="criando-a-tabela-de-endereços">Criando a tabela de endereços</h2>
<p>Primeiramente vamos criar uma tabela de endereços, nela vamos salvar os endereços dos nossos usuários, poderíamos salvar esses dados na mesma tabela do usuário, porém decidi separar para utilizarmos relacionamentos e transactions com o postgres.</p>
<p>Vamos criar uma nova migration com o comando <code>make create_migration</code>. Criamos esse comando na <a href="https://wiliamvj.com/posts/api-golang-parte-2/">parte 2</a>, com a nova migration criada, vamos escrever o sql na migration up:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span>  <span style="color:#ff79c6">CREATE</span> <span style="color:#ff79c6">TABLE</span> address (
</span></span><span style="display:flex;"><span>    id <span style="color:#8be9fd;font-style:italic">VARCHAR</span>(<span style="color:#bd93f9">36</span>) <span style="color:#ff79c6">NOT</span> <span style="color:#ff79c6">NULL</span> <span style="color:#ff79c6">PRIMARY</span> <span style="color:#ff79c6">KEY</span>,
</span></span><span style="display:flex;"><span>    cep <span style="color:#8be9fd;font-style:italic">VARCHAR</span>(<span style="color:#bd93f9">255</span>) <span style="color:#ff79c6">NOT</span> <span style="color:#ff79c6">NULL</span>,
</span></span><span style="display:flex;"><span>    ibge <span style="color:#8be9fd;font-style:italic">VARCHAR</span>(<span style="color:#bd93f9">255</span>) <span style="color:#ff79c6">NOT</span> <span style="color:#ff79c6">NULL</span>,
</span></span><span style="display:flex;"><span>    uf <span style="color:#8be9fd;font-style:italic">VARCHAR</span>(<span style="color:#bd93f9">255</span>) <span style="color:#ff79c6">NOT</span> <span style="color:#ff79c6">NULL</span>,
</span></span><span style="display:flex;"><span>    city <span style="color:#8be9fd;font-style:italic">VARCHAR</span>(<span style="color:#bd93f9">255</span>) <span style="color:#ff79c6">NOT</span> <span style="color:#ff79c6">NULL</span>,
</span></span><span style="display:flex;"><span>    complement <span style="color:#8be9fd;font-style:italic">VARCHAR</span>(<span style="color:#bd93f9">255</span>) <span style="color:#ff79c6">NULL</span>,
</span></span><span style="display:flex;"><span>    street <span style="color:#8be9fd;font-style:italic">VARCHAR</span>(<span style="color:#bd93f9">255</span>) <span style="color:#ff79c6">NOT</span> <span style="color:#ff79c6">NULL</span>,
</span></span><span style="display:flex;"><span>    created_at <span style="color:#ff79c6">TIMESTAMP</span>(<span style="color:#bd93f9">3</span>) <span style="color:#ff79c6">NOT</span> <span style="color:#ff79c6">NULL</span> <span style="color:#ff79c6">DEFAULT</span> <span style="color:#ff79c6">CURRENT_TIMESTAMP</span>,
</span></span><span style="display:flex;"><span>    updated_at <span style="color:#ff79c6">TIMESTAMP</span>(<span style="color:#bd93f9">3</span>) <span style="color:#ff79c6">NOT</span> <span style="color:#ff79c6">NULL</span>,
</span></span><span style="display:flex;"><span>    user_id <span style="color:#8be9fd;font-style:italic">VARCHAR</span>(<span style="color:#bd93f9">36</span>) <span style="color:#ff79c6">UNIQUE</span> <span style="color:#ff79c6">NOT</span> <span style="color:#ff79c6">NULL</span>,
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">FOREIGN</span> <span style="color:#ff79c6">KEY</span> (user_id) <span style="color:#ff79c6">REFERENCES</span> users(id) <span style="color:#ff79c6">ON</span> <span style="color:#ff79c6">DELETE</span> <span style="color:#ff79c6">CASCADE</span>
</span></span><span style="display:flex;"><span>  );
</span></span></code></pre></div><p>Criamos os campos que pegamos na api do viacep e adicionamos um relacionamento com o usuário (one to one), onde um usuário tem um endereço e um endereço pertence a um usuário.</p>
<p>Na migration down podemos fazer o sql que desfaz o que fizemos acima:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span>  <span style="color:#ff79c6">DROP</span> <span style="color:#ff79c6">TABLE</span> <span style="color:#ff79c6">IF</span> <span style="color:#ff79c6">EXISTS</span> address;
</span></span></code></pre></div><p>Agora podemos rodar o comando <code>make migrate_up</code>, não se esqueça de garantir que o banco de dados esteja rodando, se você clonou o repositório, basta usar o comando <code>docker compose up -d</code> que já vai subir um container com o postgres.</p>
<p>Com isso temos nossa tabela relacionanda com o usuário.</p>
<h2 id="criando-as-queries">Criando as queries</h2>
<p>Primeiro vamos criar nossas queries para salvar um usuário, buscar um usuário pelo id, buscar todos os usuários, deletar usuário, atualizar um usuário e atualizar a senha do usuário.</p>
<h3 id="createuser">CreateUser</h3>
<p>Essa query vai ser responsável por salvar um novo usuário:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span>  <span style="color:#6272a4">-- name: CreateUser :exec
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#ff79c6">INSERT</span> <span style="color:#ff79c6">INTO</span> users (id, name, email, password, created_at, updated_at)
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">VALUES</span> ($<span style="color:#bd93f9">1</span>, $<span style="color:#bd93f9">2</span>, $<span style="color:#bd93f9">3</span>, $<span style="color:#bd93f9">4</span>, $<span style="color:#bd93f9">5</span>, $<span style="color:#bd93f9">6</span>);
</span></span></code></pre></div><p>Não se esqueça das <a href="https://docs.sqlc.dev/en/latest/reference/query-annotations.html">queries annotations</a> do sqlc.</p>
<h3 id="finduserbyemail">FindUserByEmail</h3>
<p>Essa query vai ser responsável por buscar um usuário pelo e-mail:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span>  <span style="color:#6272a4">-- name: FindUserByEmail :one
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#ff79c6">SELECT</span> u.id, u.name, u.email <span style="color:#ff79c6">FROM</span> users u <span style="color:#ff79c6">WHERE</span> u.email <span style="color:#ff79c6">=</span> $<span style="color:#bd93f9">1</span>;
</span></span></code></pre></div><h3 id="finduserbyid">FindUserByID</h3>
<p>Essa query vai ser responsável por buscar um usuário pelo ID e também vamos retornar o endereço fazendo um join:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span>  <span style="color:#6272a4">-- name: FindUserByID :one
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#ff79c6">SELECT</span> u.id, u.name, u.email, u.created_At, u.updated_at, a.cep, a.uf, a.city, a.complement, a.street
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">FROM</span> users u
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">JOIN</span> address a <span style="color:#ff79c6">ON</span> a.user_id <span style="color:#ff79c6">=</span> u.id
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">WHERE</span> u.id <span style="color:#ff79c6">=</span> $<span style="color:#bd93f9">1</span>;
</span></span></code></pre></div><h3 id="updateuser">UpdateUser</h3>
<p>Essa query vai ser responsável por atualizar o usuário, usei os <a href="https://docs.sqlc.dev/en/stable/howto/named_parameters.html#nullable-parameters">nullable parameters</a> do sqlc, isso ajuda a lidar com dados nulos, como atualizar dados é opcional, caso o usuário deseja atualizar apenas o <code>name</code> por exemplo, o resto dos dados não é anulado. Sem isso precisaríamos fazer algumas validações a mais:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span>  <span style="color:#6272a4">-- name: UpdateUser :exec
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#ff79c6">UPDATE</span> users <span style="color:#ff79c6">SET</span>
</span></span><span style="display:flex;"><span>  name <span style="color:#ff79c6">=</span> COALESCE(sqlc.narg(<span style="color:#f1fa8c">&#39;name&#39;</span>), name),
</span></span><span style="display:flex;"><span>  email <span style="color:#ff79c6">=</span> COALESCE(sqlc.narg(<span style="color:#f1fa8c">&#39;email&#39;</span>), email),
</span></span><span style="display:flex;"><span>  updated_at <span style="color:#ff79c6">=</span> $<span style="color:#bd93f9">2</span>
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">WHERE</span> id <span style="color:#ff79c6">=</span> $<span style="color:#bd93f9">1</span>;
</span></span></code></pre></div><h3 id="deleteuser">DeleteUser</h3>
<p>Essa query vai ser responsável por deletar um usuário pelo id, consequentemente deleta o endereço, pois criamos o relacionamento com a opção <code>DELETE CASCADE</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span>  <span style="color:#6272a4">-- name: DeleteUser :exec
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#ff79c6">DELETE</span> <span style="color:#ff79c6">FROM</span> users <span style="color:#ff79c6">WHERE</span> id <span style="color:#ff79c6">=</span> $<span style="color:#bd93f9">1</span>;
</span></span></code></pre></div><h3 id="findmanyusers">FindManyUsers</h3>
<p>Essa query vai ser responsável por buscar todos os usuários com seus endereços, exatamente o que fizemos no <code>FindUserByID</code> mas agora sem o <code>WHERE</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span>  <span style="color:#6272a4">-- name: FindManyUsers :many
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#ff79c6">SELECT</span> u.id, u.name, u.email, u.created_At, u.updated_at, a.cep, a.uf, a.city, a.complement, a.street
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">FROM</span> users u
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">JOIN</span> address a <span style="color:#ff79c6">ON</span> a.user_id <span style="color:#ff79c6">=</span> u.id
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">ORDER</span> <span style="color:#ff79c6">BY</span> u.created_at <span style="color:#ff79c6">DESC</span>;
</span></span></code></pre></div><h3 id="updatepassword">UpdatePassword</h3>
<p>Essa query vai ser responsável por atualizar apenas a senha do usuário:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span>  <span style="color:#6272a4">-- name: UpdatePassword :exec
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#ff79c6">UPDATE</span> users <span style="color:#ff79c6">SET</span> password <span style="color:#ff79c6">=</span> $<span style="color:#bd93f9">2</span>, updated_at <span style="color:#ff79c6">=</span> $<span style="color:#bd93f9">3</span> <span style="color:#ff79c6">WHERE</span> id <span style="color:#ff79c6">=</span> $<span style="color:#bd93f9">1</span>;
</span></span></code></pre></div><h3 id="getuserpassword">GetUserPassword</h3>
<p>Essa query vai ser responsável por buscar apenas a senha do usuário:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span>  <span style="color:#6272a4">-- name: GetUserPassword :one
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#ff79c6">SELECT</span> u.password <span style="color:#ff79c6">FROM</span> users u <span style="color:#ff79c6">WHERE</span> u.id <span style="color:#ff79c6">=</span> $<span style="color:#bd93f9">1</span>;
</span></span></code></pre></div><h3 id="createuseraddress">CreateUserAddress</h3>
<p>Essa query vai ser responsável por criar o endereço do usuário na tabelas <code>address</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span>  <span style="color:#6272a4">-- name: CreateUserAddress :exec
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#ff79c6">INSERT</span> <span style="color:#ff79c6">INTO</span> address (id, user_id, cep, ibge, uf, city, complement, street, created_at, updated_at)
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">VALUES</span> ($<span style="color:#bd93f9">1</span>, $<span style="color:#bd93f9">2</span>, $<span style="color:#bd93f9">3</span>, $<span style="color:#bd93f9">4</span>, $<span style="color:#bd93f9">5</span>, $<span style="color:#bd93f9">6</span>, $<span style="color:#bd93f9">7</span>, $<span style="color:#bd93f9">8</span>, $<span style="color:#bd93f9">9</span>, $<span style="color:#bd93f9">10</span>);
</span></span></code></pre></div><h3 id="createuseraddress-1">CreateUserAddress</h3>
<p>Por fim, essa query vai atualizar o endereço do usuário, usando o <a href="https://docs.sqlc.dev/en/stable/howto/named_parameters.html#nullable-parameters">nullable parameters</a> do sqlc:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span>  <span style="color:#6272a4">-- name: UpdateUserAddress :exec
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#ff79c6">UPDATE</span> address <span style="color:#ff79c6">SET</span>
</span></span><span style="display:flex;"><span>  cep <span style="color:#ff79c6">=</span> COALESCE(sqlc.narg(<span style="color:#f1fa8c">&#39;cep&#39;</span>), cep),
</span></span><span style="display:flex;"><span>  ibge <span style="color:#ff79c6">=</span> COALESCE(sqlc.narg(<span style="color:#f1fa8c">&#39;ibge&#39;</span>), ibge),
</span></span><span style="display:flex;"><span>  uf <span style="color:#ff79c6">=</span> COALESCE(sqlc.narg(<span style="color:#f1fa8c">&#39;uf&#39;</span>), uf),
</span></span><span style="display:flex;"><span>  city <span style="color:#ff79c6">=</span> COALESCE(sqlc.narg(<span style="color:#f1fa8c">&#39;city&#39;</span>), city),
</span></span><span style="display:flex;"><span>  complement <span style="color:#ff79c6">=</span> COALESCE(sqlc.narg(<span style="color:#f1fa8c">&#39;complement&#39;</span>), complement),
</span></span><span style="display:flex;"><span>  street <span style="color:#ff79c6">=</span> COALESCE(sqlc.narg(<span style="color:#f1fa8c">&#39;street&#39;</span>), street),
</span></span><span style="display:flex;"><span>  updated_at <span style="color:#ff79c6">=</span> $<span style="color:#bd93f9">2</span>
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">WHERE</span> user_id <span style="color:#ff79c6">=</span> $<span style="color:#bd93f9">1</span>;
</span></span></code></pre></div><h3 id="gerando-o-código-sqlc">Gerando o código sqlc</h3>
<p>Com as queries escritas vamos rodar o sqlc para fazer sua mágica e gerar o código, vamos rodar com o comando:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>  sqlc generate
</span></span></code></pre></div><p>Se notar na pasta <strong>internal/database/sqlc</strong> vai perceber que foi gerado bastante código, lembrando que não é preciso alterar nada da pasta sqlc.</p>
<h2 id="finalizando-o-repository">Finalizando o repository</h2>
<p>Agora vamos ajustar nosso repository, até o momento apenas implementamos, agora vamos chamar o sqlc para fazer as execuções no nosso banco.</p>
<h3 id="createuser-1">CreateUser</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>  <span style="color:#8be9fd;font-style:italic">func</span> (r <span style="color:#ff79c6">*</span>repository) <span style="color:#50fa7b">CreateUser</span>(ctx context.Context, u <span style="color:#ff79c6">*</span>entity.UserEntity) <span style="color:#8be9fd">error</span> {
</span></span><span style="display:flex;"><span>    err <span style="color:#ff79c6">:=</span> r.queries.<span style="color:#50fa7b">CreateUser</span>(ctx, sqlc.CreateUserParams{
</span></span><span style="display:flex;"><span>      ID:        u.ID,
</span></span><span style="display:flex;"><span>      Name:      u.Name,
</span></span><span style="display:flex;"><span>      Email:     u.Email,
</span></span><span style="display:flex;"><span>      Password:  u.Password,
</span></span><span style="display:flex;"><span>      CreatedAt: u.CreatedAt,
</span></span><span style="display:flex;"><span>      UpdatedAt: u.UpdatedAt,
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">return</span> err
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    err = r.queries.<span style="color:#50fa7b">CreateUserAddress</span>(ctx, sqlc.CreateUserAddressParams{
</span></span><span style="display:flex;"><span>      ID:         uuid.<span style="color:#50fa7b">New</span>().<span style="color:#50fa7b">String</span>(),
</span></span><span style="display:flex;"><span>      UserID:     u.ID,
</span></span><span style="display:flex;"><span>      Cep:        u.Address.CEP,
</span></span><span style="display:flex;"><span>      Ibge:       u.Address.IBGE,
</span></span><span style="display:flex;"><span>      Uf:         u.Address.UF,
</span></span><span style="display:flex;"><span>      City:       u.Address.City,
</span></span><span style="display:flex;"><span>      Complement: sql.NullString{String: u.Address.Complement, Valid: u.Address.Complement <span style="color:#ff79c6">!=</span> <span style="color:#f1fa8c">&#34;&#34;</span>},
</span></span><span style="display:flex;"><span>      Street:     u.Address.Street,
</span></span><span style="display:flex;"><span>      CreatedAt:  time.<span style="color:#50fa7b">Now</span>(),
</span></span><span style="display:flex;"><span>      UpdatedAt:  time.<span style="color:#50fa7b">Now</span>(),
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">return</span> err
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></div><p>No código acima, chamamos q nossa <code>queries</code> que iniciamos lá no <code>main.go</code> (<code>queries := sqlc.New(dbConnection)</code>), chamamos o <code>CreateUser</code> que definimos na annotation (<code>-- name: CreateUser :exec</code>), por fim o sqlc criou uma struct <code>CreateUserParams</code> dentro da pasta sqlc, nela vamos passar nossos dados. Depois de criar o usuário e se não houver erro, criamos o endereço com <code>CreateUserAddress</code>, nosso repository será bastante simples já que a única responsabilidade dele é chamar o sqlc fazer as tarefas no banco e retornar dados ou um erro, nada mais que isso.</p>
<p>Reparou em um problema? no caso do método <code>CreateUser</code> realiza duas tarefas no nosso banco, imagine que se ao salvar o endereço ocorra um erro? Nosso usuário vai ficar sem endereço e isso começa a degradar nosso banco de dados, isso é um problema grave! A forma correta de tratar esse problema seria salvar esses dados de forma atômica, vamos fazer isso com transactions, mas antes vamos finalizar o repository.</p>
<h3 id="finduserbyemail-1">FindUserByEmail</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>  <span style="color:#8be9fd;font-style:italic">func</span> (r <span style="color:#ff79c6">*</span>repository) <span style="color:#50fa7b">FindUserByEmail</span>(ctx context.Context, email <span style="color:#8be9fd">string</span>) (<span style="color:#ff79c6">*</span>entity.UserEntity, <span style="color:#8be9fd">error</span>) {
</span></span><span style="display:flex;"><span>    user, err <span style="color:#ff79c6">:=</span> r.queries.<span style="color:#50fa7b">FindUserByEmail</span>(ctx, email)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>, err
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    userEntity <span style="color:#ff79c6">:=</span> entity.UserEntity{
</span></span><span style="display:flex;"><span>      ID:    user.ID,
</span></span><span style="display:flex;"><span>      Name:  user.Name,
</span></span><span style="display:flex;"><span>      Email: user.Email,
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">&amp;</span>userEntity, <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></div><p>Buscar nosso usuário pelo e-mail é bem simples, passamos o contexto e o e-mail e depois tratamos para retornar o <code>UserEntity</code>, nesse caso o <code>FindUserByEmail</code> poderia retornar apenas um <code>boolean</code>, já utilizar apenas para saber se um usuário existe ou não, mas vamos manter assim por enquanto.</p>
<h3 id="finduserbyid-1">FindUserByID</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>  <span style="color:#8be9fd;font-style:italic">func</span> (r <span style="color:#ff79c6">*</span>repository) <span style="color:#50fa7b">FindUserByID</span>(ctx context.Context, id <span style="color:#8be9fd">string</span>) (<span style="color:#ff79c6">*</span>entity.UserEntity, <span style="color:#8be9fd">error</span>) {
</span></span><span style="display:flex;"><span>    user, err <span style="color:#ff79c6">:=</span> r.queries.<span style="color:#50fa7b">FindUserByID</span>(ctx, id)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>, err
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    userEntity <span style="color:#ff79c6">:=</span> entity.UserEntity{
</span></span><span style="display:flex;"><span>      ID:    user.ID,
</span></span><span style="display:flex;"><span>      Name:  user.Name,
</span></span><span style="display:flex;"><span>      Email: user.Email,
</span></span><span style="display:flex;"><span>      Address: entity.UserAddress{
</span></span><span style="display:flex;"><span>        CEP:        user.Cep,
</span></span><span style="display:flex;"><span>        UF:         user.Uf,
</span></span><span style="display:flex;"><span>        City:       user.City,
</span></span><span style="display:flex;"><span>        Complement: user.Complement.String,
</span></span><span style="display:flex;"><span>        Street:     user.Street,
</span></span><span style="display:flex;"><span>      },
</span></span><span style="display:flex;"><span>      CreatedAt: user.CreatedAt,
</span></span><span style="display:flex;"><span>      UpdatedAt: user.UpdatedAt,
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">&amp;</span>userEntity, <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></div><p>Muito semelhante ao <code>FindUserByEmail</code>, porém agora nosso critério de busca é pelo <code>ID</code> e retornamos o endereço.</p>
<h3 id="updateuser-1">UpdateUser</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>  <span style="color:#8be9fd;font-style:italic">func</span> (r <span style="color:#ff79c6">*</span>repository) <span style="color:#50fa7b">UpdateUser</span>(ctx context.Context, u <span style="color:#ff79c6">*</span>entity.UserEntity) <span style="color:#8be9fd">error</span> {
</span></span><span style="display:flex;"><span>    err <span style="color:#ff79c6">:=</span> r.queries.<span style="color:#50fa7b">UpdateUser</span>(ctx, sqlc.UpdateUserParams{
</span></span><span style="display:flex;"><span>      ID:        u.ID,
</span></span><span style="display:flex;"><span>      Name:      sql.NullString{String: u.Name, Valid: u.Name <span style="color:#ff79c6">!=</span> <span style="color:#f1fa8c">&#34;&#34;</span>},
</span></span><span style="display:flex;"><span>      Email:     sql.NullString{String: u.Email, Valid: u.Email <span style="color:#ff79c6">!=</span> <span style="color:#f1fa8c">&#34;&#34;</span>},
</span></span><span style="display:flex;"><span>      UpdatedAt: u.UpdatedAt,
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">return</span> err
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    err = r.queries.<span style="color:#50fa7b">UpdateUserAddress</span>(ctx, sqlc.UpdateUserAddressParams{
</span></span><span style="display:flex;"><span>      UserID:     u.ID,
</span></span><span style="display:flex;"><span>      Cep:        sql.NullString{String: u.Address.CEP, Valid: u.Address.CEP <span style="color:#ff79c6">!=</span> <span style="color:#f1fa8c">&#34;&#34;</span>},
</span></span><span style="display:flex;"><span>      Ibge:       sql.NullString{String: u.Address.IBGE, Valid: u.Address.IBGE <span style="color:#ff79c6">!=</span> <span style="color:#f1fa8c">&#34;&#34;</span>},
</span></span><span style="display:flex;"><span>      Uf:         sql.NullString{String: u.Address.UF, Valid: u.Address.UF <span style="color:#ff79c6">!=</span> <span style="color:#f1fa8c">&#34;&#34;</span>},
</span></span><span style="display:flex;"><span>      City:       sql.NullString{String: u.Address.City, Valid: u.Address.City <span style="color:#ff79c6">!=</span> <span style="color:#f1fa8c">&#34;&#34;</span>},
</span></span><span style="display:flex;"><span>      Complement: sql.NullString{String: u.Address.Complement, Valid: u.Address.Complement <span style="color:#ff79c6">!=</span> <span style="color:#f1fa8c">&#34;&#34;</span>},
</span></span><span style="display:flex;"><span>      Street:     sql.NullString{String: u.Address.Street, Valid: u.Address.Street <span style="color:#ff79c6">!=</span> <span style="color:#f1fa8c">&#34;&#34;</span>},
</span></span><span style="display:flex;"><span>      UpdatedAt:  time.<span style="color:#50fa7b">Now</span>(),
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">return</span> err
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></div><p>Para atualizar um usuário também é muito simples, a única diferença que temos do <code>CreateUser</code> é que precisamos tratar os dados que são opcionais, como utilizamos o nullable parameters do sqlc, foi gerado a struct dessa forma:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>  <span style="color:#8be9fd;font-style:italic">type</span> UpdateUserParams <span style="color:#8be9fd;font-style:italic">struct</span> {
</span></span><span style="display:flex;"><span>    ID        <span style="color:#8be9fd">string</span>
</span></span><span style="display:flex;"><span>    UpdatedAt time.Time
</span></span><span style="display:flex;"><span>    Name      sql.NullString
</span></span><span style="display:flex;"><span>    Email     sql.NullString
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></div><p>Por isso usamos o <code>sql.NullString</code> caso o dado seja do tipo não <code>null</code> no contexto que estamos, então devemos atualizar, caso contrário não alteramos nada no banco.</p>
<p>Novamente o método <code>UpdateUser</code> atualiza o usuário e endereço, temos o mesmo problema do <code>CreateUser</code> e vamos resolver com transactions.</p>
<h3 id="deleteuser-1">DeleteUser</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>  <span style="color:#8be9fd;font-style:italic">func</span> (r <span style="color:#ff79c6">*</span>repository) <span style="color:#50fa7b">DeleteUser</span>(ctx context.Context, id <span style="color:#8be9fd">string</span>) <span style="color:#8be9fd">error</span> {
</span></span><span style="display:flex;"><span>    err <span style="color:#ff79c6">:=</span> r.queries.<span style="color:#50fa7b">DeleteUser</span>(ctx, id)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">return</span> err
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></div><p>Esse deve ser o mais simples, apenas deletamos o usuário, sem retorar nada.</p>
<h3 id="findmanyusers-1">FindManyUsers</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>  <span style="color:#8be9fd;font-style:italic">func</span> (r <span style="color:#ff79c6">*</span>repository) <span style="color:#50fa7b">FindManyUsers</span>(ctx context.Context) ([]entity.UserEntity, <span style="color:#8be9fd">error</span>) {
</span></span><span style="display:flex;"><span>    users, err <span style="color:#ff79c6">:=</span> r.queries.<span style="color:#50fa7b">FindManyUsers</span>(ctx)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>, err
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">var</span> usersEntity []entity.UserEntity
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">for</span> _, user <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> users {
</span></span><span style="display:flex;"><span>      userEntity <span style="color:#ff79c6">:=</span> entity.UserEntity{
</span></span><span style="display:flex;"><span>        ID:    user.ID,
</span></span><span style="display:flex;"><span>        Name:  user.Name,
</span></span><span style="display:flex;"><span>        Email: user.Email,
</span></span><span style="display:flex;"><span>        Address: entity.UserAddress{
</span></span><span style="display:flex;"><span>          CEP:        user.Cep,
</span></span><span style="display:flex;"><span>          UF:         user.Uf,
</span></span><span style="display:flex;"><span>          City:       user.City,
</span></span><span style="display:flex;"><span>          Street:     user.Street,
</span></span><span style="display:flex;"><span>          Complement: user.Complement.String,
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>        CreatedAt: user.CreatedAt,
</span></span><span style="display:flex;"><span>        UpdatedAt: user.UpdatedAt,
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      usersEntity = <span style="color:#8be9fd;font-style:italic">append</span>(usersEntity, userEntity)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> usersEntity, <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></div><p>Para buscar todos os usuário também não tem segredo, a única coisa diferente que fazemos é um <code>for</code> para mapear os dados para um slice de <code>entity.UserEntity</code>.</p>
<h3 id="updatepassword-1">UpdatePassword</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>  <span style="color:#8be9fd;font-style:italic">func</span> (r <span style="color:#ff79c6">*</span>repository) <span style="color:#50fa7b">UpdatePassword</span>(ctx context.Context, pass, id <span style="color:#8be9fd">string</span>) <span style="color:#8be9fd">error</span> {
</span></span><span style="display:flex;"><span>    err <span style="color:#ff79c6">:=</span> r.queries.<span style="color:#50fa7b">UpdatePassword</span>(ctx, sqlc.UpdatePasswordParams{
</span></span><span style="display:flex;"><span>      ID:        id,
</span></span><span style="display:flex;"><span>      Password:  pass,
</span></span><span style="display:flex;"><span>      UpdatedAt: time.<span style="color:#50fa7b">Now</span>(),
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">return</span> err
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></div><p>Para atualizar a senha do usuário, apenas passamos a nova senha, id e um nova data para informar sua atualização.</p>
<h3 id="getuserpassword-1">GetUserPassword</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>  <span style="color:#8be9fd;font-style:italic">func</span> (r <span style="color:#ff79c6">*</span>repository) <span style="color:#50fa7b">GetUserPassword</span>(ctx context.Context, id <span style="color:#8be9fd">string</span>) (<span style="color:#8be9fd">string</span>, <span style="color:#8be9fd">error</span>) {
</span></span><span style="display:flex;"><span>    pass, err <span style="color:#ff79c6">:=</span> r.queries.<span style="color:#50fa7b">GetUserPassword</span>(ctx, id)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">return</span> <span style="color:#f1fa8c">&#34;&#34;</span>, err
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> pass, <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></div><p>Por fim, esse método usamos apenas para buscar a senha do usuário, alterei para retornar apenas uma <code>string</code> nos últimos posts ele retornava um ponteiro do <code>entity.UserEntity</code>, não se esqueça de alterar na interface <code>user_interface_repository</code>.</p>
<p>Nosso repository está quase pronto, como pode perceber é bastante simples e com pouca responsabilidade no nosso projeto, antes de partir para as transactions vamos fazer alguns ajustes na nossa api.</p>
<h2 id="ajustando-o-service">Ajustando o service</h2>
<p>Vamos precisar ajustar algumas coisas no service, alguns tratamentos que acabei esquecendo de passar.</p>
<p>No método <code>CreateUser</code> do service, precisamos tratar ao verificar se o usuário existe pelo e-mail se o repository retornar um erro e esse erro for diferente de um erro do tipo <code>sql.ErrNoRows</code>, então temos um erro que devemos retornar, isso garante que seja retornado apenas um erro que não esperamos, quando o postgres do pacote pg não encontra um registro no banco é retornado um <code>sql.ErrNoRows</code> que nada mais é que um <code>errors.New(&quot;sql: no rows in result set&quot;)</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>  userExists, err <span style="color:#ff79c6">:=</span> s.repo.<span style="color:#50fa7b">FindUserByEmail</span>(ctx, u.Email)
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> sql.ErrNoRows { <span style="color:#6272a4">// adicione esse if
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>      slog.<span style="color:#50fa7b">Error</span>(<span style="color:#f1fa8c">&#34;error to search user by email&#34;</span>, <span style="color:#f1fa8c">&#34;err&#34;</span>, err, slog.<span style="color:#50fa7b">String</span>(<span style="color:#f1fa8c">&#34;package&#34;</span>, <span style="color:#f1fa8c">&#34;userservice&#34;</span>))
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">return</span> err
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></div><p>Precisamos ajustar também no método <code>UpdateUser</code>, caso o erro seja do tipo <code>sql.ErrNoRows</code> significa que não encontrou o usuário.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>  _, err <span style="color:#ff79c6">:=</span> s.repo.<span style="color:#50fa7b">FindUserByID</span>(ctx, id)
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">==</span> sql.ErrNoRows {
</span></span><span style="display:flex;"><span>      slog.<span style="color:#50fa7b">Error</span>(<span style="color:#f1fa8c">&#34;user not found&#34;</span>, slog.<span style="color:#50fa7b">String</span>(<span style="color:#f1fa8c">&#34;package&#34;</span>, <span style="color:#f1fa8c">&#34;userservice&#34;</span>))
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">return</span> errors.<span style="color:#50fa7b">New</span>(<span style="color:#f1fa8c">&#34;user not found&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    slog.<span style="color:#50fa7b">Error</span>(<span style="color:#f1fa8c">&#34;error to search user by id&#34;</span>, <span style="color:#f1fa8c">&#34;err&#34;</span>, err, slog.<span style="color:#50fa7b">String</span>(<span style="color:#f1fa8c">&#34;package&#34;</span>, <span style="color:#f1fa8c">&#34;userservice&#34;</span>))
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> err
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></div><p>Caso o usuário informe um e-mail para atualização, precisamos validar também:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>  <span style="color:#ff79c6">if</span> u.Email <span style="color:#ff79c6">!=</span> <span style="color:#f1fa8c">&#34;&#34;</span> {
</span></span><span style="display:flex;"><span>    userExists, err <span style="color:#ff79c6">:=</span> s.repo.<span style="color:#50fa7b">FindUserByEmail</span>(ctx, u.Email)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> sql.ErrNoRows {
</span></span><span style="display:flex;"><span>        slog.<span style="color:#50fa7b">Error</span>(<span style="color:#f1fa8c">&#34;error to search user by email&#34;</span>, <span style="color:#f1fa8c">&#34;err&#34;</span>, err, slog.<span style="color:#50fa7b">String</span>(<span style="color:#f1fa8c">&#34;package&#34;</span>, <span style="color:#f1fa8c">&#34;userservice&#34;</span>))
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">return</span> errors.<span style="color:#50fa7b">New</span>(<span style="color:#f1fa8c">&#34;error to search user by email&#34;</span>)
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> userExists <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>      slog.<span style="color:#50fa7b">Error</span>(<span style="color:#f1fa8c">&#34;user already exists&#34;</span>, slog.<span style="color:#50fa7b">String</span>(<span style="color:#f1fa8c">&#34;package&#34;</span>, <span style="color:#f1fa8c">&#34;userservice&#34;</span>))
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">return</span> errors.<span style="color:#50fa7b">New</span>(<span style="color:#f1fa8c">&#34;user already exists&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    updateUser.Email = u.Email
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></div><h2 id="alterando-o-response">Alterando o response</h2>
<p>Precisamos adicionar o address ao response, vamos alterar o <code>user_response.go</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>  <span style="color:#8be9fd;font-style:italic">type</span> UserResponse <span style="color:#8be9fd;font-style:italic">struct</span> {
</span></span><span style="display:flex;"><span>    ID        <span style="color:#8be9fd">string</span>      <span style="color:#f1fa8c">`json:&#34;id&#34;`</span>
</span></span><span style="display:flex;"><span>    Name      <span style="color:#8be9fd">string</span>      <span style="color:#f1fa8c">`json:&#34;name&#34;`</span>
</span></span><span style="display:flex;"><span>    Email     <span style="color:#8be9fd">string</span>      <span style="color:#f1fa8c">`json:&#34;email&#34;`</span>
</span></span><span style="display:flex;"><span>    Address   UserAddress <span style="color:#f1fa8c">`json:&#34;address&#34;`</span>
</span></span><span style="display:flex;"><span>    CreatedAt time.Time   <span style="color:#f1fa8c">`json:&#34;created_at&#34;`</span>
</span></span><span style="display:flex;"><span>    UpdatedAt time.Time   <span style="color:#f1fa8c">`json:&#34;updated_at&#34;`</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#8be9fd;font-style:italic">type</span> UserAddress <span style="color:#8be9fd;font-style:italic">struct</span> {
</span></span><span style="display:flex;"><span>    CEP        <span style="color:#8be9fd">string</span> <span style="color:#f1fa8c">`json:&#34;cep&#34;`</span>
</span></span><span style="display:flex;"><span>    UF         <span style="color:#8be9fd">string</span> <span style="color:#f1fa8c">`json:&#34;uf&#34;`</span>
</span></span><span style="display:flex;"><span>    City       <span style="color:#8be9fd">string</span> <span style="color:#f1fa8c">`json:&#34;city&#34;`</span>
</span></span><span style="display:flex;"><span>    Complement <span style="color:#8be9fd">string</span> <span style="color:#f1fa8c">`json:&#34;complement,omitempty&#34;`</span>
</span></span><span style="display:flex;"><span>    Street     <span style="color:#8be9fd">string</span> <span style="color:#f1fa8c">`json:&#34;street&#34;`</span>
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></div><h2 id="alterando-o-auth">Alterando o auth</h2>
<p>Vamos modificar o <code>auth_service.go</code> não vamos mais retornar a senha no método <code>FindUserByEmail</code>, para isso vamos buscar a senha do usuários com o método <code>GetUserPassword</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>  pass, err <span style="color:#ff79c6">:=</span> s.repo.<span style="color:#50fa7b">GetUserPassword</span>(ctx, user.ID)
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>    slog.<span style="color:#50fa7b">Error</span>(<span style="color:#f1fa8c">&#34;error to search user password&#34;</span>, <span style="color:#f1fa8c">&#34;err&#34;</span>, err, slog.<span style="color:#50fa7b">String</span>(<span style="color:#f1fa8c">&#34;package&#34;</span>, <span style="color:#f1fa8c">&#34;userservice&#34;</span>))
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>, errors.<span style="color:#50fa7b">New</span>(<span style="color:#f1fa8c">&#34;error to search user password&#34;</span>)
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></div><p>Agora para comparar as senhas usamos o <code>pass</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>  err = bcrypt.<span style="color:#50fa7b">CompareHashAndPassword</span>([]<span style="color:#8be9fd;font-style:italic">byte</span>(pass), []<span style="color:#8be9fd;font-style:italic">byte</span>(u.Password))
</span></span></code></pre></div><p>o mesmo no método <code>UpdateUserPassword</code> do <code>user_service.go</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>  oldPass, err <span style="color:#ff79c6">:=</span> s.repo.<span style="color:#50fa7b">GetUserPassword</span>(ctx, id)
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>    slog.<span style="color:#50fa7b">Error</span>(<span style="color:#f1fa8c">&#34;error to get user password&#34;</span>, <span style="color:#f1fa8c">&#34;err&#34;</span>, err, slog.<span style="color:#50fa7b">String</span>(<span style="color:#f1fa8c">&#34;package&#34;</span>, <span style="color:#f1fa8c">&#34;userservice&#34;</span>))
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> err
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></div><p>Agora usamos o <code>oldPass</code> para comparar:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span> <span style="color:#6272a4">// compare passwords
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  err = bcrypt.<span style="color:#50fa7b">CompareHashAndPassword</span>([]<span style="color:#8be9fd;font-style:italic">byte</span>(oldPass), []<span style="color:#8be9fd;font-style:italic">byte</span>(u.OldPassword))
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>    slog.<span style="color:#50fa7b">Error</span>(<span style="color:#f1fa8c">&#34;invalid password&#34;</span>, slog.<span style="color:#50fa7b">String</span>(<span style="color:#f1fa8c">&#34;package&#34;</span>, <span style="color:#f1fa8c">&#34;userservice&#34;</span>))
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> errors.<span style="color:#50fa7b">New</span>(<span style="color:#f1fa8c">&#34;invalid password&#34;</span>)
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#6272a4">// compare new password with password in database
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  err = bcrypt.<span style="color:#50fa7b">CompareHashAndPassword</span>([]<span style="color:#8be9fd;font-style:italic">byte</span>(oldPass), []<span style="color:#8be9fd;font-style:italic">byte</span>(u.Password))
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">==</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>    slog.<span style="color:#50fa7b">Error</span>(<span style="color:#f1fa8c">&#34;new password is equal to old password&#34;</span>, slog.<span style="color:#50fa7b">String</span>(<span style="color:#f1fa8c">&#34;package&#34;</span>, <span style="color:#f1fa8c">&#34;userservice&#34;</span>))
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> errors.<span style="color:#50fa7b">New</span>(<span style="color:#f1fa8c">&#34;new password is equal to old password&#34;</span>)
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></div><h2 id="melhorando-o-arquivo-http">Melhorando o arquivo http</h2>
<p>Nosso arquivo <code>http_client.http</code> precisamos definir o token de autenticação de forma manual após fazer login, vamos usar um &ldquo;trick&rdquo; do <a href="https://github.com/Huachao/vscode-restclient">rest client</a> para deixar dinâmico:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-http" data-lang="http"><span style="display:flex;"><span># @name login
</span></span><span style="display:flex;"><span><span style="color:#50fa7b">POST</span> http://localhost:8080/auth/login <span style="color:#ff79c6">HTTP</span><span style="color:#ff79c6">/</span><span style="color:#bd93f9">1.1</span>
</span></span><span style="display:flex;"><span>content-type<span style="color:#ff79c6">:</span> application/json
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">&#34;email&#34;</span>: <span style="color:#f1fa8c">&#34;john.doe3@email.com&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">&#34;password&#34;</span>: <span style="color:#f1fa8c">&#34;12345678@&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>@token = { {login.response.body.access_token} }
</span></span></code></pre></div><p>Definimos um nome para esse endpoint com o <code>@name login</code>, depois pegamos o token da resposta e colocamos no <code>@token</code>, agora podemos usar o <code>token</code> nos demais endpoints, dessa forma:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-http" data-lang="http"><span style="display:flex;"><span><span style="color:#50fa7b">GET</span> http://localhost:8080/user/list-all <span style="color:#ff79c6">HTTP</span><span style="color:#ff79c6">/</span><span style="color:#bd93f9">1.1</span>
</span></span><span style="display:flex;"><span>content-type<span style="color:#ff79c6">:</span> application/json
</span></span><span style="display:flex;"><span>Authorization<span style="color:#ff79c6">:</span> Bearer { {token} }
</span></span></code></pre></div><p>Agora não precisamos mais ficar copiando o token e colocando em cada endpoint 😎.</p>
<p>Se quiser saber mais sobre esse truques veja aqui nas <a href="https://github.com/Huachao/vscode-restclient">docs</a>.</p>
<h2 id="trabalhando-com-transactions">Trabalhando com transactions</h2>
<p>Temos um problema para salvar e editar um usuário, como são dois comandos executados um após o outro (salvar usuário e salvar endereço) e não queremos um usuário sem endereço e um endereço sem usuário, caso ocorra um erro ao salvar qualquer um dos dados, o outro já aconteceu, por exemplo:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> (r <span style="color:#ff79c6">*</span>repository) <span style="color:#50fa7b">CreateUser</span>(ctx context.Context, u <span style="color:#ff79c6">*</span>entity.UserEntity) <span style="color:#8be9fd">error</span> {
</span></span><span style="display:flex;"><span>    err <span style="color:#ff79c6">:=</span> r.queries.<span style="color:#50fa7b">CreateUser</span>(ctx, sqlc.CreateUserParams{
</span></span><span style="display:flex;"><span>      ID:        u.ID,
</span></span><span style="display:flex;"><span>      Name:      u.Name,
</span></span><span style="display:flex;"><span>      Email:     u.Email,
</span></span><span style="display:flex;"><span>      Password:  u.Password,
</span></span><span style="display:flex;"><span>      CreatedAt: u.CreatedAt,
</span></span><span style="display:flex;"><span>      UpdatedAt: u.UpdatedAt,
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">return</span> err
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    err = r.queries.<span style="color:#50fa7b">CreateUserAddress</span>(ctx, sqlc.CreateUserAddressParams{
</span></span><span style="display:flex;"><span>      ID:         uuid.<span style="color:#50fa7b">New</span>().<span style="color:#50fa7b">String</span>(),
</span></span><span style="display:flex;"><span>      UserID:     u.ID,
</span></span><span style="display:flex;"><span>      Cep:        u.Address.CEP,
</span></span><span style="display:flex;"><span>      Ibge:       u.Address.IBGE,
</span></span><span style="display:flex;"><span>      Uf:         u.Address.UF,
</span></span><span style="display:flex;"><span>      City:       u.Address.City,
</span></span><span style="display:flex;"><span>      Complement: sql.NullString{String: u.Address.Complement, Valid: u.Address.Complement <span style="color:#ff79c6">!=</span> <span style="color:#f1fa8c">&#34;&#34;</span>},
</span></span><span style="display:flex;"><span>      Street:     u.Address.Street,
</span></span><span style="display:flex;"><span>      CreatedAt:  time.<span style="color:#50fa7b">Now</span>(),
</span></span><span style="display:flex;"><span>      UpdatedAt:  time.<span style="color:#50fa7b">Now</span>(),
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">return</span> err
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></div><p>Perceba que criamos primeiro o usuário, esse comando já foi efetuado no banco, caso ocorra um erro ao salvar o endereço o usuário criado no primeiro comando o usuário vai ficar sem endereço, isso gera um problema sério para a nossa aplicação, precisamos garantir que seja salvo todos os dados ou nada seja salvo em caso de erro, por isso precisamos fazer isso de forma atômica.</p>
<p>Como assim? Utilizando transactions o comando de salvar o usuário e o endereço entram em uma única transação, que por sua vez só pode ter dois resultados possíveis ou salvamos todos os dados corretamente ou nada é salvo. Digamos que aconteça um erro ao salvar o endereço, mas o usuário já foi salvo, utilizando transaction o usuário seria removido do banco (roll back), pois o comando de salvar endereço falhou, se tudo ocorrer com sucesso tudo é salvo (commit). Uma transação pode ter várias operações, no nosso exemplo vamos utilizar apenas duas que são salvar o usuário e seu endereço ou é tudo salvo com sucesso ou nada é salvo.</p>
<p>Transactions são um assunto um pouco mais complexo, não vou me aprofundar, quero apenas mostrar a forma correta de executar vários comandos no banco de dados sem perder dados e degradar o banco.</p>
<p>Vou mostrar um exemplo do problema:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> (r <span style="color:#ff79c6">*</span>repository) <span style="color:#50fa7b">CreateUser</span>(ctx context.Context, u <span style="color:#ff79c6">*</span>entity.UserEntity) <span style="color:#8be9fd">error</span> {
</span></span><span style="display:flex;"><span>    err <span style="color:#ff79c6">:=</span> r.queries.<span style="color:#50fa7b">CreateUser</span>(ctx, sqlc.CreateUserParams{
</span></span><span style="display:flex;"><span>      ID:        u.ID,
</span></span><span style="display:flex;"><span>      Name:      u.Name,
</span></span><span style="display:flex;"><span>      Email:     u.Email,
</span></span><span style="display:flex;"><span>      Password:  u.Password,
</span></span><span style="display:flex;"><span>      CreatedAt: u.CreatedAt,
</span></span><span style="display:flex;"><span>      UpdatedAt: u.UpdatedAt,
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">return</span> err
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> errors.<span style="color:#50fa7b">New</span>(<span style="color:#f1fa8c">&#34;error&#34;</span>)
</span></span><span style="display:flex;"><span>    err = r.queries.<span style="color:#50fa7b">CreateUserAddress</span>(ctx, sqlc.CreateUserAddressParams{
</span></span><span style="display:flex;"><span>      ID:         uuid.<span style="color:#50fa7b">New</span>().<span style="color:#50fa7b">String</span>(),
</span></span><span style="display:flex;"><span>      UserID:     u.ID,
</span></span><span style="display:flex;"><span>      Cep:        u.Address.CEP,
</span></span><span style="display:flex;"><span>      Ibge:       u.Address.IBGE,
</span></span><span style="display:flex;"><span>      Uf:         u.Address.UF,
</span></span><span style="display:flex;"><span>      City:       u.Address.City,
</span></span><span style="display:flex;"><span>      Complement: sql.NullString{String: u.Address.Complement, Valid: u.Address.Complement <span style="color:#ff79c6">!=</span> <span style="color:#f1fa8c">&#34;&#34;</span>},
</span></span><span style="display:flex;"><span>      Street:     u.Address.Street,
</span></span><span style="display:flex;"><span>      CreatedAt:  time.<span style="color:#50fa7b">Now</span>(),
</span></span><span style="display:flex;"><span>      UpdatedAt:  time.<span style="color:#50fa7b">Now</span>(),
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">return</span> err
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></div><p>Adicionei um return <code>return errors.New(&quot;error&quot;)</code> logo após salvar o usuário, vamos testar e chamar o endpoint de criação de usuário:</p>
<p><img alt="Dbeaver" src="/posts/api-golang-parte-6/usghfgh65gfGFjhgj.png"></p>
<p>O usuário foi criado com sucesso.</p>
<p><img alt="Dbeaver" src="/posts/api-golang-parte-6/sdfsdfs5fghGH34456.png"></p>
<p>Porém o endereço não foi salvo, devido ao return que adicionamos para simular um erro.</p>
<h3 id="utilizando-transactions">Utilizando transactions</h3>
<p>O sqlc já oferece suporte a transactions, veja nas <a href="https://docs.sqlc.dev/en/latest/howto/transactions.html">docs</a>.</p>
<p>Vamos criar uma pasta chamada <strong>transaction</strong> dentro da pasta <strong>repository</strong> e um arquivo chamado <code>run_transaction.go</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>  <span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">Run</span>(ctx context.Context, c <span style="color:#ff79c6">*</span>sql.DB, fn <span style="color:#8be9fd;font-style:italic">func</span>(<span style="color:#ff79c6">*</span>sqlc.Queries) <span style="color:#8be9fd">error</span>) <span style="color:#8be9fd">error</span> {
</span></span><span style="display:flex;"><span>    tx, err <span style="color:#ff79c6">:=</span> c.<span style="color:#50fa7b">BeginTx</span>(ctx, <span style="color:#ff79c6">nil</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">return</span> err
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    q <span style="color:#ff79c6">:=</span> sqlc.<span style="color:#50fa7b">New</span>(tx)
</span></span><span style="display:flex;"><span>    err = <span style="color:#50fa7b">fn</span>(q)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">if</span> errRb <span style="color:#ff79c6">:=</span> tx.<span style="color:#50fa7b">Rollback</span>(); errRb <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">return</span> fmt.<span style="color:#50fa7b">Errorf</span>(<span style="color:#f1fa8c">&#34;error on rollback: %v, original error: %w&#34;</span>, errRb, err)
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">return</span> err
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> tx.<span style="color:#50fa7b">Commit</span>()
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></div><p>Esse código vamos utilizar para injetar durante a execução do sqlc, ele vai ser responsável por dar <code>rollBack</code> e caso de erro e fazer o <code>commit</code> em caso de sucesso.</p>
<p>Perceba que é bem semelhante ao que fazemos no main iniciando o sqlc com <code>sqlc.New(tx)</code>, o <code>BeginTx</code> pode ser um pouco mais complexo de entender, ele vai recebe um o <code>nil</code> se trata do isolate level, podemos definir níveis de isolamento para a nossa transação, mas como disse é um assunto mais complexo, vamos deixar o isolamento padrão. Veja mais sobre isolate level nesse <a href="https://medium.com/nerd-for-tech/understanding-database-isolation-levels-c4ebcd55c6b9">post</a>.</p>
<p>Bom, com a nossa função pronta, podemos alterar o método <code>CreateUser</code> do nosso repository, ficando assim:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>  <span style="color:#8be9fd;font-style:italic">func</span> (r <span style="color:#ff79c6">*</span>repository) <span style="color:#50fa7b">CreateUser</span>(ctx context.Context, u <span style="color:#ff79c6">*</span>entity.UserEntity) <span style="color:#8be9fd">error</span> {
</span></span><span style="display:flex;"><span>    err <span style="color:#ff79c6">:=</span> transaction.<span style="color:#50fa7b">Run</span>(ctx, r.db, <span style="color:#8be9fd;font-style:italic">func</span>(q <span style="color:#ff79c6">*</span>sqlc.Queries) <span style="color:#8be9fd">error</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#8be9fd;font-style:italic">var</span> err <span style="color:#8be9fd">error</span>
</span></span><span style="display:flex;"><span>      err = q.<span style="color:#50fa7b">CreateUser</span>(ctx, sqlc.CreateUserParams{
</span></span><span style="display:flex;"><span>        ID:        u.ID,
</span></span><span style="display:flex;"><span>        Name:      u.Name,
</span></span><span style="display:flex;"><span>        Email:     u.Email,
</span></span><span style="display:flex;"><span>        Password:  u.Password,
</span></span><span style="display:flex;"><span>        CreatedAt: u.CreatedAt,
</span></span><span style="display:flex;"><span>        UpdatedAt: u.UpdatedAt,
</span></span><span style="display:flex;"><span>      })
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">return</span> err
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      err = q.<span style="color:#50fa7b">CreateUserAddress</span>(ctx, sqlc.CreateUserAddressParams{
</span></span><span style="display:flex;"><span>        ID:         uuid.<span style="color:#50fa7b">New</span>().<span style="color:#50fa7b">String</span>(),
</span></span><span style="display:flex;"><span>        UserID:     u.ID,
</span></span><span style="display:flex;"><span>        Cep:        u.Address.CEP,
</span></span><span style="display:flex;"><span>        Ibge:       u.Address.IBGE,
</span></span><span style="display:flex;"><span>        Uf:         u.Address.UF,
</span></span><span style="display:flex;"><span>        City:       u.Address.City,
</span></span><span style="display:flex;"><span>        Complement: sql.NullString{String: u.Address.Complement, Valid: u.Address.Complement <span style="color:#ff79c6">!=</span> <span style="color:#f1fa8c">&#34;&#34;</span>},
</span></span><span style="display:flex;"><span>        Street:     u.Address.Street,
</span></span><span style="display:flex;"><span>        CreatedAt:  time.<span style="color:#50fa7b">Now</span>(),
</span></span><span style="display:flex;"><span>        UpdatedAt:  time.<span style="color:#50fa7b">Now</span>(),
</span></span><span style="display:flex;"><span>      })
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">return</span> err
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>      slog.<span style="color:#50fa7b">Error</span>(<span style="color:#f1fa8c">&#34;error to create user and address, roll back applied&#34;</span>, <span style="color:#f1fa8c">&#34;err&#34;</span>, err)
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">return</span> err
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></div><p>Agora usamos a função <code>Run</code> que criamos, passamos o contexto, conexão com o banco e o ponteiro das nossas queries do sqlc, a partir de agora tudo que acontecer dentro dessa função é uma transaction única. Também precisamos usar as queries do sqlc está no parâmetro <code>q</code> da função anônima, antes usávamos do <code>r.queries</code>, se houver qualquer erro agora nossa transaction vai fazer um rollback, se tudo ocorrer com sucesso vamos ter um commit da transação.</p>
<p>Você pode fazer novamente o teste e colocar o <code>return errors.New(&quot;error&quot;)</code> antes de salvar o endereço do usuário, depois olhe no banco, vai perceber que o usuário não foi salvo, inclusive nossa api já vai retornar um erro 400 para o cliente.</p>
<h3 id="implementando-no-updateuser">Implementando no UpdateUser</h3>
<p>Vamos alterar também nosso método <code>UpdateUser</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>  <span style="color:#8be9fd;font-style:italic">func</span> (r <span style="color:#ff79c6">*</span>repository) <span style="color:#50fa7b">UpdateUser</span>(ctx context.Context, u <span style="color:#ff79c6">*</span>entity.UserEntity) <span style="color:#8be9fd">error</span> {
</span></span><span style="display:flex;"><span>    err <span style="color:#ff79c6">:=</span> transaction.<span style="color:#50fa7b">Run</span>(ctx, r.db, <span style="color:#8be9fd;font-style:italic">func</span>(q <span style="color:#ff79c6">*</span>sqlc.Queries) <span style="color:#8be9fd">error</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#8be9fd;font-style:italic">var</span> err <span style="color:#8be9fd">error</span>
</span></span><span style="display:flex;"><span>      err = r.queries.<span style="color:#50fa7b">UpdateUser</span>(ctx, sqlc.UpdateUserParams{
</span></span><span style="display:flex;"><span>        ID:        u.ID,
</span></span><span style="display:flex;"><span>        Name:      sql.NullString{String: u.Name, Valid: u.Name <span style="color:#ff79c6">!=</span> <span style="color:#f1fa8c">&#34;&#34;</span>},
</span></span><span style="display:flex;"><span>        Email:     sql.NullString{String: u.Email, Valid: u.Email <span style="color:#ff79c6">!=</span> <span style="color:#f1fa8c">&#34;&#34;</span>},
</span></span><span style="display:flex;"><span>        UpdatedAt: u.UpdatedAt,
</span></span><span style="display:flex;"><span>      })
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">return</span> err
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      err = r.queries.<span style="color:#50fa7b">UpdateUserAddress</span>(ctx, sqlc.UpdateUserAddressParams{
</span></span><span style="display:flex;"><span>        UserID:     u.ID,
</span></span><span style="display:flex;"><span>        Cep:        sql.NullString{String: u.Address.CEP, Valid: u.Address.CEP <span style="color:#ff79c6">!=</span> <span style="color:#f1fa8c">&#34;&#34;</span>},
</span></span><span style="display:flex;"><span>        Ibge:       sql.NullString{String: u.Address.IBGE, Valid: u.Address.IBGE <span style="color:#ff79c6">!=</span> <span style="color:#f1fa8c">&#34;&#34;</span>},
</span></span><span style="display:flex;"><span>        Uf:         sql.NullString{String: u.Address.UF, Valid: u.Address.UF <span style="color:#ff79c6">!=</span> <span style="color:#f1fa8c">&#34;&#34;</span>},
</span></span><span style="display:flex;"><span>        City:       sql.NullString{String: u.Address.City, Valid: u.Address.City <span style="color:#ff79c6">!=</span> <span style="color:#f1fa8c">&#34;&#34;</span>},
</span></span><span style="display:flex;"><span>        Complement: sql.NullString{String: u.Address.Complement, Valid: u.Address.Complement <span style="color:#ff79c6">!=</span> <span style="color:#f1fa8c">&#34;&#34;</span>},
</span></span><span style="display:flex;"><span>        Street:     sql.NullString{String: u.Address.Street, Valid: u.Address.Street <span style="color:#ff79c6">!=</span> <span style="color:#f1fa8c">&#34;&#34;</span>},
</span></span><span style="display:flex;"><span>        UpdatedAt:  time.<span style="color:#50fa7b">Now</span>(),
</span></span><span style="display:flex;"><span>      })
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">return</span> err
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>      slog.<span style="color:#50fa7b">Error</span>(<span style="color:#f1fa8c">&#34;error to update user and address, roll back applied&#34;</span>, <span style="color:#f1fa8c">&#34;err&#34;</span>, err)
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">return</span> err
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></div><p>Agora com a função <code>Run</code> feita, podemos usar facilmente onde precisar efetuar mais de um comando no banco de dados.</p>
<h2 id="atualizando-as-docs">Atualizando as docs</h2>
<p>Para finalizar vamos gerar novamente as nossas docs, já que modificamos o response, basta rodar o comando:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>  swag init -g internal/handler/routes/docs_route.go
</span></span></code></pre></div><h2 id="considerações-finais">Considerações finais</h2>
<p>Nesse post conseguimos finalizar a nosso repository, persistindo os dados no banco, também utilizamos transactions, deixando nossa api mais robusta.</p>
<h2 id="próximos-passos">Próximos passos</h2>
<p>Estamos chegando na reta final da nossa série, espero que esteja curtindo. Na parte 7 vamos implementar a parte de produtos, desde o handler até o repository.</p>
<h2 id="link-do-repositório">Link do repositório</h2>
<p><a href="https://github.com/wiliamvj/api-users-golang">repositório</a> do projeto</p>
<p>Se inscreva e receba um aviso sobre novos posts, <a href="https://wiliamvj.substack.com/">participar</a></p>
<p><a href="https://github.com/egonelbre/gophers">Gopher credits</a></p>
</section>

  
    
  
    <div class="giscus-comment">
    <script
      src="https://giscus.app/client.js"
      data-repo="wiliamvj/wiliamvj.com"
      data-repo-id="R_kgDOKqMPTA"
      data-category="General"
      data-category-id="DIC_kwDOKqMPTM4CbzWf"
      data-mapping="pathname"
      data-strict="0"
      data-reactions-enabled="1"
      data-emit-metadata="0"
      data-input-position="top"
      data-theme="dark"
      data-lang="en"
      
        data-loading="lazy"
      
      crossorigin="anonymous"
      async
    >
    </script>
</div>
  

    
  


  <footer>
    
  </footer>
</article>

</main><footer class="pt-5 pb-6 lg:grid lg:gap-3 lg:grid-cols-2">
  <div class="text-xs font-semibold text-gray-500 order-2 sm:order-1">
  © 2024 —
  <a href="//localhost:1313/">Wiliam V. Joaquim</a>
  <span class="font-normal">with</span>
  <a
    href="https://github.com/nixentric/Lowkey-Hugo-Theme"
    target="_blank"
    rel="noopener noreferrer"
  >
    Lowkey
  </a>
</div>
 <div class="order-1 sm:order-2">
  <ul class="flex sm:justify-end gap-5">
     
    <li>
      <a href="https://www.linkedin.com/in/wiliamvj/" target="_blank" rel="noopener noreferrer"
        >linkedin</a
      >
    </li>
    
    <li>
      <a href="https://twitter.com/wiliamjoaquim" target="_blank" rel="noopener noreferrer"
        >x</a
      >
    </li>
    
    <li>
      <a href="https://github.com/wiliamvj" target="_blank" rel="noopener noreferrer"
        >github</a
      >
    </li>
    
    <li>
      <a href="https://dev.to/wiliamvj" target="_blank" rel="noopener noreferrer"
        >dev.to</a
      >
    </li>
     
  </ul>
</div>

</footer>
</body>
</html>
